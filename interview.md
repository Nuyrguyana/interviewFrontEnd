# HTML
### Отличие блочных и строчных элементов
#### Строчные
`<span>`, `<a/>`, `<img/>`

- ширина зависит от содержимого
- Нельзя задать ширину и высоту
- Не переносится на новую строку 
- Может содержать в себе только контент и другие строчные элементы
#### Блочные
`<div>`, `<p>` , `<ul>`, `<ol>`, `<h1>`…`<h6>`
- по умолчанию занимают всю ширину страницы 
- начинаются с новой строки 
- могут содержать в себе другие блочные или строчные элементы

### Структура HTML

```html

<doctype html> - тип документа
<html> - вся страница
    <head> - основная инфа (заголовок, кодировка, мета инфа, подключение стилей)
    </head>
    <body> - содержание страницы
    </body>
</html>
```

### Семантическая верстка

Семантическая верстка - это подход к разметке, которая опирается на смысловое предназначение и логическую структуру документа,
чтобы сделать приложение доступным. Например, с помощью скринридера, человек с особенностями может ориентироваться по сайту
Чтобы поисковики выдавали результат выше

Примеры тегов:

- `<header>` - шапка сайта
- `<main>` - основное содержимое
- `<footer>` - подвал сайта
- `<nav>` - навигация по сайту (ссылки)
- `<section>` - для разделения на секции. Обязательный дочерний элемент - заголовок
- `<article>` - для статей, записей, новостей. Обязательный дочерний элемент - заголовок
- `<asade>` - боковая панель сайта

### Какие браузеры поддерживают HTML5?
Практически все браузеры, но можно проверить совместимость версий языка с браузера на сайте [caniuse.com](https://caniuse.com/)

### Почему важно указывать атрибут alt для img?
Атрибут alt устанавливает альтернативный текст для изображений. Например, у браузера отключена загрузка изображений, вместо него будет текстовая информация.

### Для чего нужны Data атрибуты?
Data атрибуты позволяют хранить дополнительную информацию в стандартных элементах html

# CSS
### Разница display: none и visibility: hidden
- `display: none` полностью скрывает элемент со страницы и всё выглядит так, как если бы его вообще не было
- `visibility: hidden` просто делает элемент невидимым, но сохраняет занимаемое им место

# JavaScript
### Отличия var, let, const
- var - глобальная область видимости, можно вызвать до её определения (hoisting) 
- let - область видимости блочная, то есть где она объявлена, там и доступна. Вызывать можно только после её определения, иначе будут ошибки. Можно переопределить 
- const - нельзя переопределить

### Типы данных
8 типов данных (7 примитивов и 1 непримитив)
- string - строка 
- number - число 
- boolean - логическое значение true/false 
- null - специальное значение, указывает на его отсутствие 
- underfined - специальное значение, указывает на то, что значение не установлено 
- symbol - уникальное значение, часто применяется для обращения к свойствам сложных объектов 
- bigint - очень большое число 
- object - комплексный объект, составной тип данных, туда же массивы и функции

### Как можно привести одни типы к другим?
Преобразовать можно к string, number, boolean
- явное преобразование
```javascript
const age = 2
String(age) // "2"
```
- неявное с помощью конкатенации значения со строкой
 (к строке приводиться только при сложении)
В остальных случаях (-, /, *) приравнивается к числу
```javascript
const age = 30 + "2" // "302"
```
### В чем разница null и undefined?
null указывает на отсутствие значения, а undefined на его неопределенность

### Что такое замыкание (closures) ?
Замыкание - это функция в функции, то есть внутренняя функция имеет доступ к данным родительской функции.

### Как создать объект в js?
- через синтаксис «конструктор объекта»
```javascript
let user = new Object
```
- через синтаксис «литерал объекта»
```javascript
let user = { } // свойство - пара «ключ:значение»
```
### Разница строгой и нестрогой проверки на равенство
Нестрогое равенство не сравнивает по типу

### Какое значение имеет this?
This - ключевое слово, которое указывает на текущий контекст выполнения кода, если использовать this внутри какого-либо объекта, то this ссылается именно на этот объект

### Что такое NaN, как проверить является ли значение NaN?
NaN - not a number (не число), способ проверки через функцию 
```javascript
isNaN(значение)
```

### Основные методы массивов?
- map - применяет к каждому элементу массива какое-то действие. Возвращает новый измененный массив, не изменяя предыдущий
- forEach - изменяет исходный массив 
- filter - фильтрует массив по какому-то условию. Возвращает новый массив 
- splice - удаляет элемент из массива и добавляет на ее место другой. Не возвращает новый массив 
- slice - обрезает массив 
- pop - удаляет последний элемент массива 
- push - добавляет элемент в начало массива 
- shift - удаляет первый элемент массива 
- unshift - добавляет элемент в начало массива 
- find - ищет элемент по условию. Выведет только первый найденный элемент, даже если условию удовлетворяют несколько элементов 
- findIndex - ищет индекс по условию. Возвращает индекс искомого элемента, либо возвращает -1, если условие не выполнено, то есть элемент не найден 
- indexOf - ищет элемент в массиве и возвращает его индекс 
- reduce - применяет функцию reducer к каждому элементу массива, возвращая одно результирующее значение. Принимает 4 аргумента, один из них аккумулятор - это необязательный параметр, используемый в качестве первого аргумента при первом вызове функции callback. Например можно посчитать сумму чисел в массиве

### Методы строк
- toUpperCase, toLowerCase (смена регистра)
- indexOf, includes (поиск символов в строке)
- slice, substring (обрезка строки)
- replace, replaceAll (замена символов в строке
- repeat (повторение строки несколько раз)
- trim (удаление лишних пробелов)

### Отличие между while и for
- for принимает в себя 3 параметра - начальное значение, условие, шаг
- while вернет true/false 

### ООП - объектно ориентированное программирование (парадигма - это способ мышления, способ восприятия чего-либо)
- абстракция - выделение важного для решения задач
- инкапсуляция - сокрытие сложной реализации под понятным интерфейсом
- наследование - перенятие свойств и методов одного класса другим 
- полиморфизм - возможность метода работать с аргументом и его наследниками

### Event loop
Event loop - это событийный цикл, бесконечный цикл в котором JS ожидает задачи, выполняет их и ждет новые.
У него есть свой порядок, выполнения:
- сначала выполняются все макрозадачи (callstack выполнение кода от первой строчки до последней)
- вызывает все, что есть в очереди микрозадач (microtask queue - promise (than/catch/finally))
- вызывает все, что есть в очереди вызовов (callback queue - setTimeOut, setInterval)

### Способы для сравнения объектов ?
- JSON.stringify - конвертирует объекты в строку и сравнивает.
  Но если свойства объектов идут не в одном порядке, то сравнение вернет false
- с помощью библиотеки _lodash, есть метод _.isEqual(объект1, объект2)

### Для чего webpack и какие задачи он выполняет
Webpack - это сборщик модулей. Он анализирует модули приложения, создает граф зависимостей, затем собирает модули в правильном порядке в один или более бандл (bundle), на который может ссылаться файл (index.html)

Если загрузить скрипт, зависящий от React, до загрузки самого React, приложение сломается.  Webpack - решает эти задачи. Не нужно беспокоиться о последовательности подключения всех скриптов

### Что такое Promise ?
Promise - это обещание дождаться выполнения операции и после продолжить работу. Принимает в себя resolve (функция вызывается если promise был выполнен успешно), reject (не успешно).

Методы promise:
- then - выполняется когда выполнится promise
- catch - выполнится, если в promise ошибка
- finally - выполнится в любом случае

### Методы bind, call, apply - привязывают контекст к какой-либо функции
- в метод call параметры функции передаются через запятую
- в метод apply в массив
- отличие bind от call и apply, в том что bind не вызывает функцию, он создает новую функцию с новым контекстом.
Параметры передаются через запятую, как и в call.

### Зачем нужны async/await?
С then/catch/finally - вызовы растут вправо, это не удобно. А с async/await - все идет линейно, код становить более читабельным

### Разница setTimeOut и setInterval
- setTimeOut - позволяет вызвать функцию один раз через определенный интервал времени
- setInterval - позволяет вызывать функцию регулярно, повторяя вызов через определенный интервал времени 

### Основные нововведения в es6
- let
- де структуризация (сразу достаю свойства)
- стрелочные функции

### Виды тестирования 
- Юнит - тестирование 1 компонента
- Интеграционное - тестирование группы компонентов
- Системное - тестирование всего

### Что такое чистая функция?
Это функция работающая только с теми аргументами, которые в нее передали, и не имеющая side эффектов (сторонних эффектов). То есть делает, что-то одно

### Запросы 
- post - изменяет состояние сервера (создает какие-то сущности) - не безопасный и не идемпотентный запрос
- put - обновляет сущность на сервере - не безопасный и идемпотентный 
- get - получает - безопасный и идемпотентный
- delete - удаляет - не безопасный и не идемпотентный 

Идемпотентный - это при повторном вызове запроса ответ будет тем же

### Зачем нужна асинхронность и какую проблему она решает?
Асинхронность - это способ взаимодействия с данными, когда не знаешь, в какой точно момент появятся данные.

Если код работает синхронно, то пользователь не сможет взаимодействовать со страницей, пока не придет результат.

Асинхронный код позволяет избежать этого. Он убирает блокирующую операцию из основного потока, пока она где-то продолжает выполняться, а обработчик может идти дальше

### Разница стрелочной и обычной функции

### Зачем нужен оператор typeof?
Оператор typeof позволяет определить тип параметра. Он возвращает строку содержащую тип (string, number, object)

Особенности:
- Для null оператор возвращает object
- Для функций оператор возвращает function

### Различие function declaration и function expression
- function declaration - должно содержать ключевое слово function, вызвать можно как до так и после его определения
- function expression - вызвать можно только после определения

### Минусы callback функции
Функция должна быть выполнена после того, как другая функция завершила выполнение

Легко потеряться во вложенности

### Что такое hoisting?
Hoisting (поднятие) - значит, что объявление переменной или функции перемещается в начало кода

# React - библиотека
### Для чего в React используется Virtual Dom?
Самые затратные операции в JS - это работа с DOM-дерево, это такие функции как `document.querySelector` или `getElementById`.

То есть каждый раз, когда мы берем JS и делаем доступ до DOM-дерево, то требуется некоторое количество времени для того, чтобы найти и получить в JS.

Когда приложение интерактивное и много взаимодействий, оно может тормозить.

Virtual Dom - легковесный JS объект, который представляет копию реального DOM-дерева

Нужен он для оптимизации взаимодействия с DOM

### Основные хуки
- useState - управление состояние функционального компонента React
```jsx
const [state, setState] = useState() // state - переменная, которая хранит само состояние
// setState - функция, которая меняет состояние
// (initialState) - начальное значение состояния
```
- useEffect - используя этот хук. мы говорим React сделать что-то после рендера.
  React запомнит это и вызовет функцию после того, как внесет изменения в DOM
```jsx
useEffect (() => {
}, []) // [] - зависимости, при изменении которых срабатывает рендер
```

- useContext - получение контекста в дочерних элементах
- useHistory 
- useLocation 
- useTable из React.Table

#### Преимущество хуков
Хуки - это функции, с помощью которых можно подцепиться к состоянию и методам жизненного цикла React из функциональных компонентов

Хуки позволяют повторно использовать логику состояния, писать код проще, эффективнее использовать функционал, упрощает разработку за счет декларативности

### Для чего нужен ref?
`ref` - это атрибут в React, который помогает хранить ссылку на определенный элемент или компонент, который будет возвращен функцией конфигурации рендеринга компонентов.

Нужен:
- для интеграции со сторонами библиотеки
- когда нужно работать с фокусом, выделить текст или работа с медиа

### Что такое состояние React?
State - это объект, которые определяют рендеринг и поведение компонентов. Он му табельный и создает динамические и интерактивные компоненты.

### Фазы жизненного цикла компонентов React
- Инициализация - на этом этапе компонент React готовит установку начального состояния и параметров по умолчанию
- Монтирование - компонент React готов для монтирования в DOM браузера. Этот этап охватывает методы жизненного цикла `componentWillMount` и `componentDidMount`
- Обновление - на этом этапе компонент обновляется двумя способами, отправляя свойства и обновляя состояние. Этот этап охватывает методы жизненного цикла `shouldComponentUpdate`, `componentWillUpdate`, `componentDidUpdate`
- Размонтирование - на этом последнем этапе компонент не нужен и отключается из DOM браузера, этот этап включает метод `componentWillUnmount`

### Что такое компоненты высшего порядка (High Order Component)?
HOC это кастомный компонент, который оборачивает другой компонент. Может принять любой динамически предоставленный дочерний компонент, но они не будут изменять или копировать любое поведение из своих компонентов. Можно сказать что HOC это чистый компонент.

### Действия с HOC
- Переиспользование кода, логики 
- Абстракция и манипуляция state 
- Манипуляция с props

# Redux
### Что такое Redux?
Это предсказуемый контейнер состояний для приложений JavaScript, который используется для управления состоянием всего приложения. 

_**Примечание:**_ Приложения, разработанные с помощью Redux, легко тестируются и могут работать в разных средах, демонстрируя согласованное поведение.

### Принципы Redux?
- Единый источник правды: Состояние всего приложения хранится в дереве объектов/состояний в одном хранилище. Единое дерево состояний облегчает отслеживание изменений и отладку или проверку приложения.
- State только для чтения: Единственный способ изменить state вызвать Action. Action - это просто объект JS описывающий изменение. 
- Изменения сделаны чистыми функциями: Чтобы указать, как дерево состояний трансформируется действиями, вам нужны чистые функции.

### Принцип "Единый источник правды" в Redux
Redux использует Store для хранения всего состояния приложения в одном месте. Таким образом все состояние компонента хранится в Store, и они получают обновления от самого Store. Единое дерево состояний облегчает отслеживание изменений во времени и отладку или проверку приложения.

## Компоненты Redux
- Action - Объект, который описывает что происходит 
- Reducer - Место, где определяется как state изменится 
- Store - Состояние/Объект дерева всего приложения которое хранится в Store 
- View - Отображает данные, предоставленные Store

### Как Actions определяются в Redux?
Action в React должны иметь свойство type которое показывает тип Action. Они должны быть определены как строковая константа, можно добавить еще свойства. В Redux actions создаются при помощи функции которая возвращает типа и данные.

### Объясните роль Reducer?
Reducers это чистые функции которые описывают как состояние приложения изменяется в ответ на Action. Reducer работает принимая прежнее состояние и действие, а затем возвращает новое состояние. Он определяет, какое обновление необходимо выполнить, основываясь на типе действия, а затем возвращает новые значение. Возвращает предыдущее состояние если не нужно выполнять никаких действий.

### Каково назначение Store в Redux?
Store - это JavaScript объект, который содержит состояние приложения и предоставляет несколько вспомогательных методов для доступа к состоянию, рассылает действия и регистрирует слушателей. Все дерево состояний/объектов приложения сохраняется в одном хранилище. 

В результате Redux очень просто и предсказуем. Мы можем передать промежуточное программное обеспечение в хранилище для обработки данных, а также для ведения журнала различных действий, которые изменяют состояние хранилищ. Все действия возвращают новое состояние через reducers.

# Git
# TypeScript