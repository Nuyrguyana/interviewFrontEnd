# HTML
### Отличие блочных и строчных элементов
#### Строчные
`<span>`, `<a/>`, `<img/>`

- ширина зависит от содержимого
- Нельзя задать ширину и высоту
- Не переносится на новую строку 
- Может содержать в себе только контент и другие строчные элементы
#### Блочные
`<div>`, `<p>` , `<ul>`, `<ol>`, `<h1>`…`<h6>`
- по умолчанию занимают всю ширину страницы 
- начинаются с новой строки 
- могут содержать в себе другие блочные или строчные элементы

### Структура HTML

```html

<doctype html> - тип документа
<html> - вся страница
    <head> - основная инфа (заголовок, кодировка, мета инфа, подключение стилей)
    </head>
    <body> - содержание страницы
    </body>
</html>
```

### Семантическая верстка

Семантическая верстка - это подход к разметке, которая опирается на смысловое предназначение и логическую структуру документа,
чтобы сделать приложение доступным. Например, с помощью скринридера, человек с особенностями может ориентироваться по сайту
Чтобы поисковики выдавали результат выше

Примеры тегов:

- `<header>` - шапка сайта
- `<main>` - основное содержимое
- `<footer>` - подвал сайта
- `<nav>` - навигация по сайту (ссылки)
- `<section>` - для разделения на секции. Обязательный дочерний элемент - заголовок
- `<article>` - для статей, записей, новостей. Обязательный дочерний элемент - заголовок
- `<asade>` - боковая панель сайта

### Какие браузеры поддерживают HTML5?
Практически все браузеры, но можно проверить совместимость версий языка с браузера на сайте [caniuse.com](https://caniuse.com/)

### Почему важно указывать атрибут `alt` для `img`?
Атрибут `alt` устанавливает альтернативный текст для изображений. Например, у браузера отключена загрузка изображений, вместо него будет текстовая информация.

### Для чего нужны Data атрибуты?
Data атрибуты позволяют хранить дополнительную информацию в стандартных элементах html

---
# CSS (Cascade Style Sheet)
### Единицы измерения 
- `px` - абсолютные
- `em` - относительно размера шрифта родителя
- `rem` - относительно размера шрифта HTML
- `vm` - относительно размеров экрана
- `vh` - относительно размеров экрана

### Что такое псевдоклассы?
Псевдокласс в CSS — это ключевое слово, добавленное к селектору, которое определяет его особое состояние. Нужен для интерактива элементов.
### Какие есть псевдоклассы?
- `:hover` - наведение курсором на элемент
- `:focus` - состояние фокуса. Выбранный элемент выделяется
- `:active` - выделение элемента при нажатии
- `:visited` - меняет цвет, если на элемент уже нажимали
- `:disabled` - если задан одноименный атрибут кнопке, то применится этот псевдокласс, после `:hover` делает кнопку неактивной

### Для чего нужны псевдоэлементы?
Для декорации
### Какие есть псевдоэлементы?
- `::after` - вставляет содержимое _**после**_ элемента
- `::before` - вставляет содержимое _**до**_ элемента
_**Прим.:**_ Обязательное свойство для этих псевдоэлементов - `content: ""`
- `::first-letter` - первая буква с индивидуальными стилями
- `::first-line` - первая строка с индивидуальными стилями

### Вес селекторов от меньшего к большему
1. Тег
2. class
3. class тег (вложенность)
4. id 
5. `!important`
6. атрибут HTML _**style**_
7. атрибут HTML _**style `!important`**_

## Position
- `static` - по умолчанию
- `relative` - устанавливается относительно его изначального положения.
- `absolute` - позиционируется относительно странице, как бы выдергиваясь из контекста. Если родительскому блоку установить `position: relative`, то блок с `position: absolute` будет перемещен относительно родительского блока
- `fixed` - так же как и `position: absolute` вырывает блок из потока и фиксируется относительно окна браузера
- `sticky` - гибрид `position: static` и `position: fixed`, блок статичен, но как только скрол достигает границу блока, он фиксируется и прибивается как в случае `position: fixed`

## Display
Свойство, которое определяет, как элемент должен быть показан в документе 
- `block` - элемент показывается как блочный. Из строчного можно сделать блочный и к нему применятся свойства как у блочного 
- `inline` - элемент показывается как строчный
- `inline-block` - ведет себя как строчный элемент, но указывая св-ва блочного элемента, они применяются к нему (ширина, высота, отступы)
- `none` - удаляет блок, как будто бы его и не было
- `flex` - элементы отрисовываются в ряд относительно их контейнера, к которому применен `flex`. Сам контейнер остается блочным.
- `inline-flex` - подобен `inline-block`
- `grid`

### Display flex
К `flex` можно применить сво-во `justify-content`, которое определяет выравнивание вдоль основной оси. По умолчанию `justify-content:flex`. Также есть значения:
- `flex-start` - определяет адаптивность всех элементов под самый высокий элемент. Занимает столько сколько нужно и прижимает их к верху контейнера
- `flex-end` - то же что и `flex-start`, но прижимает к низу контейнера
- `center` - становится по центру относительно самого высокого эл-та
- `flex-wrap` - если эл-там не хватает места в контейнере, они смещаются ниже. Адаптация `nowrap` отменяет адаптацию. `wrap-reverse` так же как и `wrap`, но перемещение будет задом на перед. 
- `space-between` - 
- `space-around` - Пространство с каждой стороны эл-та (лево\право)
- `align-items` - определяет поведение вдоль поперечной оси (по оси столбца). По умолчанию `align-items:stretch`. Элементы подстраиваются под высоту самого высокого эл-та.
- `align-content` - тип выравнивания строк внутри flex-контейнера по поперечной оси при наличии свободного пространства.
- `order` (цифра) - определяет порядок элементов. От меньшего к большему.
- `flex-grow` (цифра) - задаёт коэффициент роста для заданного числа

### Display grid
- `inline-grid` - формирует сетку как строчный элемент
- `grid-template-columns` - определяет размеры grid-колонок. Можно указывать в `px` (точный размер), в `px` и `fr` (остаточная ширина), `repeat` (число колонок, px(размер, ширина))
- `grid-template-rows` - определяет размеры grid-строк. Можно указывать в `px` (точный размер), в `px` и `fr` (остаточная высота), `repeat` (число строк, px(размер, высота))
- `gap` - задаёт отступы между столбцами и строками
- `align-items` - выравнивает вдоль оси столбца
- `align-content` - выравнивает сетку вдоль оси колонки
- `justify-items` - выравнивает содержимое вдоль оси строки
- `justify-content` - выравнивает сетку вдоль оси строки
- `grid-auto-flow` - `row` заполняет строки по очереди, `column` заполняет столбцы по очереди
- `justify-self` - выравнивает содержимое эл-та вдоль оси строки
- `align-self` - выравнивает содержимое эл-та вдоль оси столбца

### Разница между `flexbox` и `grid`
- `flexbox` позиционирует эл-ты в одном направлении, строке или колонке
- `grid` позиционирует эл-ты в двумерной системе, то есть одновременно и в строке и в колонке.

### display:table
- `display:table`
- `display:table-row`
- `display:table-header-group`
- `display:table-row-group`
- `display:table-footer-group`
- `display:table-column`
- `display:table-column-group`
- `display:table-ceil`
- `display:table-caption`
- 
### Разница display: none и visibility: hidden
- `display: none` полностью скрывает элемент со страницы и всё выглядит так, как если бы его вообще не было
- `visibility: hidden` просто делает элемент невидимым, но сохраняет занимаемое им место

### z-index
`z-index` меняет положение по оси Z. Чем больше индекс, тем выше будет находиться эл-т

### Для чего нужен `box-sizing:border-box`?
На размер блока ничего не будет влиять. Border, padding и пр. будут идти внутрь, а контент будет уменьшаться.

### Отцентровка
- по горизонтали: text-align:center
- по вертикали ???

## Препроцессоры
### Какую проблему решают препроцессоры и зачем они нужны?
- С помощью препроцессора можно указать переменную в которой будет храниться св-во, и далее использовать жту переменную. И в случае когда свойство поменялось, сделать это можно только в переменной. В остальные места подтянется.
- Можно использовать _**import**_, то есть в один файл подтянуть все остальные файлы CSS, и на выходе получить только один файл который подгружается `@include`
- В обычном CSS нужно указываться родительский блок и его вложенность. При использовании препроцессора можно этого избежать. Т.е. написать один раз род. блок и вкладывать в него элементы.
- _**Миксины**_ (Mixin) - примесь стилей позволяет сделать блок силей, которые могут быть неоднократно использованы.

### Миксины
`@mixin <имя миксина> {параметры}
p{@include имя;}`

```scss
@mixin mixinName($color, $width){
  border: {
    color: $color;
    width: $width;
  };
}
p{
  @include mixinName(red, 2px);
}
```

---
# JavaScript
## Общее
### Отличия var, let, const
- var - глобальная область видимости, можно вызвать до её определения (hoisting)
- let - область видимости блочная, то есть где она объявлена, там и доступна. Вызывать можно только после её определения, иначе будут ошибки. Можно переопределить
- const - нельзя переопределить

### Как создать объект в js?
- через синтаксис «конструктор объекта» (ключевое слово `new`)
```javascript
let user = new Object()
```
- через синтаксис «литерал объекта»
```javascript
let user = { } // свойство - пара «ключ:значение»
```

### Отличие между while и for
- for принимает в себя 3 параметра - начальное значение, условие, шаг
- while выполняется пока принимаемое значение `boolean` не станет `false`

### Способы для сравнения объектов
- `JSON.stringify` - конвертирует объекты в строку и сравнивает.
  Но если свойства объектов идут не в одном порядке, то сравнение вернет false
- с помощью библиотеки __lodash_, есть метод `_.isEqual(объект1, объект2)`

### Основные нововведения в es6
- `let`
- деструктуризация (сразу достаю свойства через `{}`)
- стрелочные функции

### Виды тестирования (необязательно)
- Юнит - тестирование 1 компонента
- Интеграционное - тестирование группы компонентов
- Системное - тестирование всего приложения


### Зачем нужен оператор typeof?
Оператор typeof позволяет определить тип параметра. Он возвращает строку содержащую тип (string, number, object)

Особенности:
- Для null оператор возвращает object
- Для функций оператор возвращает function

### Что такое hoisting?
Hoisting (поднятие) - значит, что объявление переменной или функции перемещается в начало кода

## Функции

### Что такое чистая функция?
Это функция работающая только с теми аргументами, которые в нее передали, и не имеющая side эффектов (сторонних эффектов). То есть делает, что-то одно

### Что такое замыкание (closures) ?
Замыкание - это функция в функции, то есть внутренняя функция имеет доступ к данным родительской функции.

### Разница между стрелочной и обычной функции.
- В стрелочной функции отсутствует специальный объект `arguments`, содержащий в себе объект со всеми аргументами функции.
- Значение `this` внутри обыкновенной функции динамически зависит от контекста вызова. Собственный `this` внутри стрелочной функции отсутствует (`undefined`). Но когда стр. ф-ия используется в замыкании, то её `this` будет указывать на `this` внешней функции.
- Обычная функция (не анонимная) может быть вызвана до своего определения
- Если в стрелочная функция пишется в одну строку, можно не указывать `return`
- Можно использовать синтаксис стрелочных функций внутри класса. При этом в качестве `this` будет выступать объект класса.

### Различие function declaration и function expression
- _function declaration_ - должно содержать ключевое слово function, вызвать можно как до так и после его определения
- _function expression_ - вызвать можно только после определения

### Минусы callback функции
- Функция должна быть выполнена после того, как другая функция завершила выполнение 
- Легко потеряться во вложенности

## Операторы
### Разница между операторами «=», «==» и «===»
- `=` оператор присвоения
- `==` является не строгим сравнением (приводит типы данных к 1 виду)
- `===` строгое сравнение данных (без приведения типов)
### Rest & Spread операторы
В чем разница между spread-оператором и rest-оператором?
Операторы spread и rest имеют одинаковый синтаксис (`...`). Разница состоит в том, что с помощью spread мы передаем или распространяем данные массива на другие данные, а с помощью rest — получаем все параметры функции и помещаем их в массив (или извлекаем часть параметров).
### Деструктуризация
Что такое деструктуризация объекта (Object Destructuring)?
Деструктуризация — относительно новый способ получения (извлечения) значений объекта или массива. Использование деструктуризации позволяет сделать код чище и отнимает меньше времени. Синтаксис деструктуризации следующий: заключаем свойства объекта, которые хотим получить, в фигурные скобки (`{ }`), а если речь идет о массиве — в квадратные скобки (`[ ]`)
### Оператор "!!"
`!!` (двойное отрицание) приводит значение справа от него к логическому значению.
## Типы данных
8 типов данных (7 примитивов и 1 непримитив)
- string - строка 
- number - число 
- boolean - логическое значение true/false 
- null - специальное значение, указывает на его отсутствие 
- underfined - специальное значение, указывает на то, что значение не установлено 
- symbol - уникальное значение, часто применяется для обращения к свойствам сложных объектов 
- bigint - очень большое число 
- object - комплексный объект, составной тип данных, туда же массивы и функции

### В чем разница null и undefined?
null указывает на отсутствие значения, а undefined на его неопределенность

### Как можно привести одни типы к другим?
Преобразовать можно к string, number, boolean
- явное преобразование
```javascript
const age = 2
String(age) // "2"
```
- неявное с помощью конкатенации значения со строкой
 (к строке приводиться только при сложении)
В остальных случаях (-, /, *) приравнивается к числу
```javascript
const age = 30 + "2" // "302"
```

### Что такое NaN, как проверить является ли значение NaN?
NaN - not a number (не число), способ проверки через функцию
```javascript
isNaN(значение)
```

## Контекст
### Какое значение имеет this?
This - ключевое слово, которое указывает на текущий контекст выполнения кода, если использовать this внутри какого-либо объекта, то this ссылается именно на этот объект

### Методы bind, call, apply - привязывают контекст к какой-либо функции
- в метод `call()` параметры функции передаются через запятую
- в метод `apply()` в массив
- отличие `bind()` от `call()` и `apply()`, в том что `bind()` не вызывает функцию, он создает новую функцию с новым контекстом.
  Параметры передаются через запятую, как и в `call()`.

## Массивы
### Методы массивов
#### Методы вставки\удаления
- `pop()` - удаляет последний элемент массива
- `push()` - добавляет элемент в начало массива
- `shift()` - удаляет первый элемент массива
- `unshift()` - добавляет элемент в начало массива
##### Какой из этих методов быстрее и почему?
`push`/`pop` быстрее потому что работают с элементами в конце массива, а `unshift`/`shift` с его началом и для этих операций требуется переиндексация всего массива
##### Что если использовать вместо pop/shift/splice _delete_?
На месте удаленных элементов останется `undefined`
#### Методы для работы со всеми элементами массива
- `map()` - применяет к каждому элементу массива какое-то действие. Возвращает новый измененный массив, не изменяя предыдущий
- `forEach()` - изменяет исходный массив 
- `filter()` - фильтрует массив по какому-то условию. Возвращает новый массив
- `find()` - ищет элемент по условию. Выведет только первый найденный элемент, даже если условию удовлетворяют несколько элементов
- `findIndex()` - ищет индекс по условию. Возвращает индекс искомого элемента, либо возвращает -1, если условие не выполнено, то есть элемент не найден
- `indexOf()` - ищет элемент в массиве и возвращает его индекс
- `reduce()` - применяет функцию reducer к каждому элементу массива, возвращая одно результирующее значение. Принимает 4 аргумента, один из них аккумулятор - это необязательный параметр, используемый в качестве первого аргумента при первом вызове функции callback. Например можно посчитать сумму чисел в массиве
#### Другие методы
- `splice()` - удаляет элемент из массива и добавляет на его место другой. Не возвращает новый массив 
- `slice()` - обрезает массив

## Строки
### Методы строк
- `toUpperCase()`, `toLowerCase()` (смена регистра)
- `indexOf()`, `includes()` (поиск символов в строке)
- `slice()`, `substring()` (обрезка строки)
- `replace()`, `replaceAll()` (замена символов в строке
- `repeat()` (повторение строки несколько раз)
- `trim()` (удаление лишних пробелов)

## Объекты
### Что такое Object.freeze?
`Object.freeze()` замораживает объект: это значит, что он предотвращает добавление новых свойств к объекту, удаление старых свойств из объекта и изменение существующих свойств или значения их атрибутов перечисляемости, настраиваемости и записываемости. В сущности, объект становится эффективно неизменным. Метод возвращает замороженный объект.
### Что такое Object.seal?
`Object.seal()` запечатывает объект, предотвращая добавление новых свойств к объекту и делая все существующие свойства не настраиваемыми. Значения представленных свойств всё ещё могут изменяться, поскольку они остаются записываемыми
### В чем разница между методами Object.freeze и Object.seal?
Разница заключается в том, что при использовании метода `Object.freeze()` мы не можем менять или редактировать свойства объекта, а при использовании `Object.seal()` у нас такая возможность имеется

## ООП
### ООП - объектно ориентированное программирование (парадигма - это способ мышления, способ восприятия чего-либо)
- **Абстракция** - выделение важного для решения задач
- **Инкапсуляция** - сокрытие сложной реализации под понятным интерфейсом
- **Наследование** - перенятие свойств и методов одного класса другим 
- **Полиморфизм** - возможность метода работать с аргументом и его наследниками
## Events
### Event, event listerner, handler
Объект Event описывает событие, произошедшее на странице. Одной из причин возникновения событий являются действия пользователя, такие как клики мышкой MouseEvent или ввод с клавиатуры KeyboardEvent

Event listerner - прослушиватель событиий

Handler - обработчик событий

### Что такое делегирование событий???
### Что такое распространение события (Event Propagation)?
Когда какое-либо событие происходит в элементе DOM, оно на самом деле происходит не только в нем. Событие «распространяется» от объекта Window до вызвавшего его элемента (event.target). При этом событие последовательно пронизывает (затрагивает) всех предков целевого элемента. Распространение события имеет три стадии или фазы:
- Фаза погружения (захвата, перехвата) — событие возникает в объекте Window и опускается до цели события через всех ее предков. 
- Целевая фаза — это когда событие достигает целевого элемента. 
- Фаза всплытия — событие поднимается от event.target, последовательно проходит через всех его предков и достигает объекта Window.
### Что такое всплытие события?
Когда событие происходит в элементе DOM, оно затрагивает не только этот элемент. Событие «всплывает» (подобно пузырьку воздуха в воде), переходит от элемента, вызвавшего событие (event.target), к его родителю, затем поднимается еще выше, к родителю родителя элемента, пока не достигает объекта Window.
### Что такое погружение события?
Когда событие происходит в элементе DOM, оно происходит не только в нем. В фазе погружения событие опускается от объекта Window до цели события через всех его предков.
### В чем разница между методами event.preventDefault() и event.stopPropagation()?
- event.preventDefault() отключает поведение элемента по умолчанию. Если использовать этот метод в элементе form, то он предотвратит отправку формы (submit). Если использовать его в contextmenu, то контекстное меню будет отключено
- event.stopPropagation() отключает распространение события (его всплытие или погружение).
### Как узнать об использовании метода event.preventDefault()?
Для этого мы можем использовать свойство event.defaulPrevented, возвращающее логическое значение, служащее индикатором применения к элементу метода event.preventDefault.

## Ассинхронный JS
### Зачем нужна асинхронность и какую проблему она решает?
Асинхронность - это способ взаимодействия с данными, когда не знаешь, в какой точно момент появятся данные.

Если код работает синхронно, то пользователь не сможет взаимодействовать со страницей, пока не придет результат.

Асинхронный код позволяет избежать этого. Он убирает блокирующую операцию из основного потока, пока она где-то продолжает выполняться, а обработчик может идти дальше

### Event loop
Event loop - это событийный цикл, бесконечный цикл в котором JS ожидает задачи, выполняет их и ждет новые.
У него есть свой порядок, выполнения:
- сначала выполняются все макрозадачи (callstack выполнение кода от первой строчки до последней)
- вызывает все, что есть в очереди микрозадач (microtask queue - promise (than/catch/finally))
- вызывает все, что есть в очереди вызовов (callback queue - `setTimeOut()`, `setInterval()`)

### Что такое Promise ?
Promise - это обещание дождаться выполнения операции и после продолжить работу. Принимает в себя resolve (функция вызывается если promise был выполнен успешно), reject (не успешно).

Методы promise:
- `then()` - выполняется когда выполнится promise
- `catch()` - выполнится, если в promise ошибка
- `finally()` - выполнится в любом случае

### Зачем нужны async/await?
С `then()`/`catch()`/`finally()` - вызовы растут вправо, это не удобно. А с `async`/`await` - все идет линейно, код становить более читабельным

### Разница setTimeOut и setInterval
- `setTimeOut()` - позволяет вызвать функцию один раз через определенный интервал времени
- `setInterval()` - позволяет вызывать функцию регулярно, повторяя вызов через определенный интервал времени

## Сборщики проектов
### Для чего webpack и какие задачи он выполняет
Webpack - это сборщик модулей. Он анализирует модули приложения, создает граф зависимостей, затем собирает модули в правильном порядке в один или более бандл (bundle), на который может ссылаться файл (`index.html`)

Если загрузить скрипт, зависящий от React, до загрузки самого React, приложение сломается. Webpack - решает эти задачи. Не нужно беспокоиться о последовательности подключения всех скриптов

---
# Сети
### Запросы 
- GET - получает - безопасный и идемпотентный. Все данные в URL, тело запроса пустое.
- POST - изменяет состояние сервера (создает какие-то сущности). Не безопасный и не идемпотентный запрос. Все данные в теле, URL пустой
- PUT - обновляет сущность на сервере. Не безопасный и идемпотентный. Данные могут передаваться как в теле так и в URL 
- DELETE - удаляет сущность. Не безопасный и не идемпотентный. Данные могут передаваться как в теле так и в URL

Идемпотентный - это при повторном вызове запроса ответ будет тем же

---
# React - библиотека
## Общее
### Что такое React?
React — это библиотека JavaScript с открытым исходным кодом, созданная Facebook для разработки сложных интерактивных пользовательских интерфейсов в веб- и мобильных приложениях. Основная цель React — создание компонентов пользовательского интерфейса; их часто называют просто «V» (View) в архитектуре «MVC».

### Что такое JSX?
JSX является расширением синтаксиса JavaScript и поставляется с полной функциональностью JavaScript. JSX производит «элементы» React. Вы можете встроить любое выражение JavaScript в JSX, заключив его в фигурные скобки. После компиляции выражения JSX становятся обычными объектами JavaScript. Это означает, что вы можете использовать JSX внутри операторов if и циклов for, назначать его переменным, принимать в качестве аргументов и возвращать из функций.

### Что такое контролируемые компоненты?
В контролируемом компоненте данные формы обрабатываются состоянием внутри компонента. Состояние внутри компонента служит «единственным источником правды» для элементов ввода, которые отображаются компонентом. Нам не нужен элемент формы на странице, чтобы компонент был контролируемым компонентом.

### Что такое некотролируемые компоненты?
Неконтролируемые компоненты действуют больше как традиционные элементы формы HTML. Данные для каждого элемента ввода хранятся в DOM, а не в компоненте. Вместо того чтобы писать обработчик событий для всех ваших обновлений состояния, вы используете ref для получения значений из DOM.

### Фазы жизненного цикла компонентов React
- **Инициализация** - на этом этапе компонент React готовит установку начального состояния и параметров по умолчанию
- **Монтирование** - компонент React готов для монтирования в DOM браузера. Этот этап охватывает методы жизненного цикла `componentWillMount` и `componentDidMount`
- **Обновление** - на этом этапе компонент обновляется двумя способами, отправляя свойства и обновляя состояние. Этот этап охватывает методы жизненного цикла `shouldComponentUpdate`, `componentWillUpdate`, `componentDidUpdate`
- **Размонтирование** - на этом последнем этапе компонент не нужен и отключается из DOM браузера, этот этап включает метод `componentWillUnmount`

### Что такое Props?
Props это короткое название Properties в React. Они только для чтения. Они всегда передаются вниз от родителя к ребёнку. Дочерний компонент никогда не может передать prop обратно родителю. Это помогает поддерживать однонаправленный поток данных и обычно используется для рендера динамически генерируемых данных.

### Что такое состояние React?
State - это объект, которые определяют рендеринг и поведение компонентов. Он мутабельный и создает динамические и интерактивные компоненты. После изменения state происходит ре-рендер компонента

### Для чего нужны keys в React?
Ключи используются для идентификации уникальных виртуальных элементов DOM с соответствующими данными, управляющими пользовательским интерфейсом. Они помогают React оптимизировать рендеринг, перерабатывая все существующие элементы в DOM. Эти ключи должны быть уникальными числами или строками, используя которые React просто переупорядочить элементы, а не перерисовывает их. Это повышает производительность приложения.

### Для чего в React используется Virtual Dom?
Самые затратные операции в JS - это работа с DOM-дерево, это такие функции как `document.querySelector()` или `getElementById()`.

То есть каждый раз, когда мы берем JS и делаем доступ до DOM-дерево, то требуется некоторое количество времени для того, чтобы найти и получить в JS.

Когда приложение интерактивное и много взаимодействий, оно может тормозить.

Virtual Dom - легковесный JS объект, который представляет копию реального DOM-дерева

Нужен он для оптимизации взаимодействия с DOM

## Хуки
Хуки - это функции, с помощью которых можно подцепиться к состоянию и методам жизненного цикла React из функциональных компонентов
### Основные хуки
- `useState()` - управление состояние функционального компонента React
```jsx
const [state, setState] = useState() // state - переменная, которая хранит само состояние
// setState - функция, которая меняет состояние
// (initialState) - начальное значение состояния
```
- `useEffect()` - используя этот хук мы говорим React сделать что-то после рендера.
  React запомнит это и вызовет функцию после того, как внесет изменения в DOM
```jsx
useEffect (() => {
}, []) // [] - зависимости, при изменении которых срабатывает рендер
```

- `useContext()` - получение контекста в дочерних элементах
- `useHistory()` 
- `useLocation()`

#### Из сторонних библиотек
- `useTable()` из React.Table
- `useForm()`

#### Преимущество хуков
Хуки позволяют повторно использовать логику состояния, писать код проще, эффективнее использовать функционал, упрощает разработку за счет декларативности

### Для чего нужен ref?
`ref` - это атрибут в React, который помогает хранить ссылку на определенный элемент или компонент, который будет возвращен функцией конфигурации рендеринга компонентов.

Нужен:
- для интеграции со сторонами библиотеки
- когда нужно работать с фокусом, выделить текст или работа с медиа
- Для запуска императивной анимации (Императивная анимация работает в браузере основным потоком.)

### Что такое Context?
Контекст позволяет передавать данные через дерево компонентов без необходимости передавать пропсы на промежуточных уровнях.

## Паттерны

### MVC
Архитектурный паттерн в котором приложение представляется в виде 3 слоёв:
- **_Model_** - слой данных. В него входят базы данных.
- **_View_** - слой представления. В него входит весь фронт-энд.
- **_Controller_** - слой управления данными. Он же бэк-энд
### Что такое компоненты высшего порядка (High Order Component)?
HOC это кастомный компонент, который оборачивает другой компонент. Может принять любой динамически предоставленный дочерний компонент, но они не будут изменять или копировать любое поведение из своих компонентов. Можно сказать что HOC это чистый компонент.

#### Действия с HOC
- Переиспользование кода, логики 
- Абстракция и манипуляция state 
- Манипуляция с props

### Flux
Flux - это архитектурный паттерн, который обеспечивает однонаправленный поток данных. Он контролирует производные данные и обеспечивает связь между несколькими компонентами с использованием центрального хранилища, которые имеет полномочия для всех данных. Любое обновление данных должно происходить только здесь. Flux обеспечивает стабильность приложения и уменьшает ошибки во время выполнения.

---
# Redux
### Что такое Redux?
Это предсказуемый контейнер состояний для приложений JavaScript, который используется для управления состоянием всего приложения. 

_**Примечание:**_ Приложения, разработанные с помощью Redux, легко тестируются и могут работать в разных средах, демонстрируя согласованное поведение.

### Принципы Redux?
- Единый источник правды: Состояние всего приложения хранится в дереве объектов/состояний в одном хранилище. Единое дерево состояний облегчает отслеживание изменений и отладку или проверку приложения.
- State только для чтения: Единственный способ изменить state вызвать Action. Action - это просто объект JS описывающий изменение. 
- Изменения сделаны чистыми функциями: Чтобы указать, как дерево состояний трансформируется действиями, вам нужны чистые функции.

### Принцип "Единый источник правды" в Redux
Redux использует Store для хранения всего состояния приложения в одном месте. Таким образом все состояние компонента хранится в Store, и они получают обновления от самого Store. Единое дерево состояний облегчает отслеживание изменений во времени и отладку или проверку приложения.

## Компоненты Redux
- Action - Объект, который описывает что происходит 
- Reducer - Место, где определяется как state изменится 
- Store - Состояние/Объект дерева всего приложения которое хранится в Store 
- View - Отображает данные, предоставленные Store

### Как Actions определяются в Redux?
Action в React должны иметь свойство type которое показывает тип Action. Они должны быть определены как строковая константа, можно добавить еще свойства. В Redux actions создаются при помощи функции которая возвращает типа и данные.

### Объясните роль Reducer?
Reducers это чистые функции которые описывают как состояние приложения изменяется в ответ на Action. Reducer работает принимая прежнее состояние и действие, а затем возвращает новое состояние. Он определяет, какое обновление необходимо выполнить, основываясь на типе действия, а затем возвращает новые значение. Возвращает предыдущее состояние если не нужно выполнять никаких действий.

### Каково назначение Store в Redux?
Store - это JavaScript объект, который содержит состояние приложения и предоставляет несколько вспомогательных методов для доступа к состоянию, рассылает действия и регистрирует слушателей. Все дерево состояний/объектов приложения сохраняется в одном хранилище. 

В результате Redux очень просто и предсказуем. Мы можем передать промежуточное программное обеспечение в хранилище для обработки данных, а также для ведения журнала различных действий, которые изменяют состояние хранилищ. Все действия возвращают новое состояние через reducers.

---
# Git
### Разница между merge и rebase?

### Почему рекомендуют использовать концепцию git flow?

### Назовите основные команды git?

### Как можно отменить commit?

### Какой командой можно сохранить изменения в памяти?


---
# TypeScript
### Назовите плюсы и минусы TS?
Плюсы:
- строгая типизация
- интерфейсы
- ооп
- компилятор реализует подход fail fast (получаешь обр. связь в момент написания кода а не в момент тестирования)
- очень хорошая поддержка TS в редакторах кода (советы, ошибки, и  кододополнение намного лучше чем в JS)

Минусы:
- нужно больше учить (выше порог входа)
- Существующий код сложно перенести на TS 
- Код из библиотек бывает сложно читать из-за обилия дженериков и прочего

_**Прим:**_ Некоторые библиотеки и фреймворки (например Angular) работают только с TS

### Почему нерекомендуется использовать any?
Тогда TS превращается в JS, тк «убивается» типизация

### Для чего нужны дженерики?

### разница между type и interface?
- `type` не может расширяться в отличие от `interface` 
- `type` может быть объявлен только 1 раз. Если интерфейс объявляется 2 раза, то его свойства «сливаются» 
- Тип не может быть реализован, только объявлен. Интерфейс нужно реализовывать

### Зачем нужен тип unknow?
`unknown` является безопасной (с точки зрения типов) версией типа `any`.
Когда свойство объявлено как `any`, у него становится поведение как у обычного JS поля. Если поле объявлено как `unknown`, у него нельзя вызвать никакого метода или свойства без явной проверки `unknown` на конкретный тип (через `typeof`)

### Для чего нужен enum и какая разница с union типом?

### В каких случаях можно использовать картеж? (Дописать)
Это про tuple
