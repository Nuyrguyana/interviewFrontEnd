# Browsers

### Способы хранения данных в браузере

#### Cookie

Cookie является одним из методов хранения данных в браузере. Он позволяет веб-приложениям сохранять небольшие фрагменты
информации на компьютере пользователей и использовать эти данные при последующих запросах.

Например, веб-приложения могут использовать cookie для запоминания настроек пользователя, таких как язык интерфейса или
предпочтительный способ оплаты. Cookie могут также использоваться для отслеживания поведения пользователя и показа
персонализированной рекламы.

Cookie хранятся на компьютере пользователя в виде текстовых файлов, которые можно удалить или блокировать через
настройки браузера.

#### localStorage, sessionStorage

localStorage и sessionStorage являются способами хранения данных в браузере, которые предназначены для сохранения более
крупных объемов информации, чем Cookie, и дают возможность сохранять данные в течение более длительного времени.

localStorage сохраняет данные на неограниченный период, пока пользователь не удалит их или пока они не будут удалены
через код JavaScript. sessionStorage, с другой стороны, сохраняет данные только на время сеанса пользователя в браузере,
т.е. до закрытия вкладки или окна браузера.

Пример использования localStorage может быть сохранение предпочтений пользователя на сайте, таких как выбранный язык
интерфейса, чтобы на следующих посещениях сайта данные могли быть восстановлены автоматически.

Пример использования sessionStorage может быть сохранение информации о товарах, которые пользователь добавил в корзину
на сайте, чтобы не потерять их при переходе на другие страницы сайта или при закрытии браузера.

#### Indexed DB

IndexedDB (Indexed Database) - это API браузера для хранения больших объемов структурированных данных, доступных даже в
автономном режиме. Это нереляционная база данных, которая позволяет сохранять данные более эффективно, чем localStorage
и sessionStorage.

Пример использования IndexedDB может быть приложение для заметок, которое позволяет пользователям сохранять и открывать
свои заметки в браузере. Вы можете создать хранилище данных IndexedDB, где каждая заметка будет представлена объектом с
уникальным идентификатором, содержимым заметки и датой создания. Пользователи могут создавать, изменять и удалять
заметки, а также искать и открывать их в другой раз. Это все может быть легко управляемо через IndexedDB API.

#### Reflow, repaint и composite

Reflow, repaint и composite - это термины, используемые для описания процессов, которые происходят в браузере, когда
изменяются элементы на веб-странице.

Reflow - это процесс пересчета расположения элементов на странице. Он происходит, когда изменяются размеры элементов на
странице, например, при изменении размера окна браузера, изменении шрифта или добавлении новых элементов на страницу.
Reflow занимает много времени и ресурсов, поэтому он должен быть минимизирован.

Пример Reflow: Когда пользователь изменяет размер окна браузера, браузер пересчитывает расположение всех элементов на
странице, чтобы они соответствовали новым размерам окна.

Repaint - это процесс обновления отображения элементов на странице без изменения их расположения. Он происходит, когда
изменяются свойства элементов, влияющие только на их внешний вид, например, цвет фона, границы или текст.

Пример Repaint: Когда пользователь наводит курсор мыши на кнопку, она может изменять цвет фона или стиль, но ее
расположение остается прежним.

Composite - это процесс, когда браузер отображает изменения на странице после Reflow и Repaint. Он происходит после
того, как браузер заканчивает обновление отображения элементов на странице, и объединяет их в единую картинку для показа
на экране.

Пример Composite: Когда пользователь кликает на кнопку, браузер отображает изменения, связанные с Reflow и Repaint, и
затем объединяет их в одну единую картинку, которая отображается на экране.

## Виды клиент-серверного взаимодействия
- HTTP (HyperText Transfer Protocol)
   Описание: Стандартный протокол для передачи данных в интернете. Клиент отправляет запрос серверу, и сервер отвечает данными (например, веб-страницей).
   Пример: Загрузка веб-страницы через браузер.
- Long Polling
   Описание: Клиент отправляет запрос серверу и ожидает ответа. Если сервер не имеет новых данных, он не отвечает сразу, а удерживает соединение открытым до тех пор, пока не появятся новые данные. После получения данных клиент отправляет новый запрос.
   Пример: Чат-приложения, где клиент ждет новых сообщений от сервера.
- WebSocket
   Описание: Протокол, который устанавливает постоянное соединение между клиентом и сервером для двусторонней передачи данных в реальном времени. Это позволяет обмениваться сообщениями без необходимости повторных запросов.
   Пример: Онлайн-игры или приложения для обмена сообщениями, где требуется мгновенный обмен данными.
- SSE (Server-Sent Events)
   Описание: Технология, позволяющая серверу отправлять обновления клиенту через однонаправленное соединение. Клиент устанавливает соединение, и сервер может отправлять данные, когда они становятся доступными.
   Пример: Уведомления о новых сообщениях или обновлениях на веб-странице.
- REST (Representational State Transfer)
   Описание: Архитектурный стиль, использующий стандартные HTTP-методы (GET, POST, PUT, DELETE) для взаимодействия с ресурсами на сервере. Каждый ресурс имеет свой уникальный URL.
   Пример: API для работы с данными, где клиент может запрашивать, добавлять или изменять информацию.
- GraphQL
   Описание: Язык запросов для API, который позволяет клиенту запрашивать только те данные, которые ему нужны, вместо получения фиксированного набора данных.
   Пример: Клиент может запрашивать конкретные поля из сложной структуры данных, сокращая объем передаваемой информации.
- gRPC (Google Remote Procedure Call)
   Описание: Протокол удаленного вызова процедур, который использует HTTP/2 для связи между клиентом и сервером. Поддерживает двустороннюю потоковую передачу данных и более эффективное сериализованное представление данных.
   Пример: Микросервисные архитектуры, где сервисы общаются друг с другом.

### Методы HTTP
HTTP (HyperText Transfer Protocol) использует несколько стандартных методов для выполнения различных операций с ресурсами на сервере. Вот основные методы HTTP:

#### GET
   Описание: Используется для запроса данных с сервера. Запросы GET не должны изменять состояние сервера и могут кэшироваться.
   Пример: Получение веб-страницы или изображения.
#### POST
   Описание: Используется для отправки данных на сервер, например, при отправке формы. Запросы POST могут изменять состояние сервера.
   Пример: Отправка данных формы для регистрации пользователя.
#### PUT
   Описание: Используется для обновления существующего ресурса на сервере или создания нового ресурса, если он не существует. Запросы PUT обычно являются идемпотентными (повторный запрос не изменит результат).
   Пример: Обновление информации о пользователе.
#### DELETE
   Описание: Используется для удаления ресурса с сервера. Запросы DELETE также являются идемпотентными.
   Пример: Удаление учетной записи пользователя.
#### PATCH
   Описание: Используется для частичного обновления ресурса. В отличие от PUT, который требует отправить полное представление ресурса, PATCH отправляет только те данные, которые нужно изменить.
   Пример: Обновление только адреса электронной почты пользователя.
#### HEAD
   Описание: Запрашивает заголовки ресурса, но не сам ресурс. Используется для получения метаданных без загрузки содержимого.
   Пример: Проверка заголовков ответа перед загрузкой полной страницы.
#### OPTIONS
   Описание: Используется для запроса доступных методов и параметров для конкретного ресурса. Это полезно для определения того, какие действия можно выполнить с ресурсом.
   Пример: Проверка, поддерживает ли сервер метод PUT для определенного URL.
#### TRACE
   Описание: Используется для диагностики, позволяя клиенту увидеть, что сервер получает в запросе. Запрос TRACE возвращает содержимое запроса, что может помочь в отладке.
   Пример: Использование для проверки маршрута запроса.
#### CONNECT
   Описание: Используется для установления туннеля к серверу, обычно через прокси-сервер. Это может быть полезно для HTTPS-соединений.
   Пример: Установка защищенного соединения через прокси.

### Отличие PUT от PATCH: 
 - PUT: Полное обновление ресурса, требует отправки всех полей, идемпотентен.
 - PATCH: Частичное обновление ресурса, позволяет отправлять только измененные поля, не всегда идемпотентен.

## Что такое CORS?
CORS (Cross-Origin Resource Sharing) — это механизм безопасности в вебе, который позволяет браузерам контролировать, какие ресурсы могут загружаться с других доменов.

- Безопасность: CORS помогает предотвратить атаки, такие как межсайтовый скриптинг (XSS).
- Заголовки: Сервер использует заголовки, такие как Access-Control-Allow-Origin, чтобы указать, какие домены могут получать доступ к его ресурсам.
- Запросы: CORS применим только к запросам, сделанным с помощью JavaScript в браузере, и не влияет на обычные HTTP-запросы, сделанные с серверов.

## Критические этапы рендеринга
Рендеринг веб-страницы — это процесс, в ходе которого браузер преобразует HTML, CSS и JavaScript в визуальное представление, которое пользователь видит на экране. Этот процесс можно разделить на несколько критических этапов:

- Загрузка ресурсов
   Браузер отправляет HTTP-запросы на сервер для получения HTML-документа и других ресурсов (CSS, JavaScript, изображения и т. д.).
   Полученные ресурсы загружаются в браузер. 
- Парсинг HTML
   Браузер начинает парсить (анализировать) HTML-документ и строит дерево элементов (DOM — Document Object Model).
   Каждая HTML-тег становится узлом в дереве.
- Парсинг CSS
   Одновременно с парсингом HTML браузер парсит CSS-файлы и встроенные стили, создавая дерево стилей (CSSOM — CSS Object Model).
   Это дерево содержит информацию о стилях, применяемых к элементам DOM.
- Создание рендер-дерева
   Браузер объединяет DOM и CSSOM для создания рендер-дерева.
   Рендер-дерево содержит только те узлы, которые должны быть отображены на экране, и включает в себя информацию о стилях для каждого элемента.
- Расчет геометрии (layout)
   На этом этапе браузер вычисляет размеры и положение каждого элемента на странице.
   Этот процесс называется layout или reflow.
- Рисование (painting)
   Браузер начинает рисовать элементы на экране, начиная с фона и заканчивая текстом и изображениями.
   Этот процесс называется painting.
- Составление слоев (compositing)
   В современных браузерах элементы могут быть разделены на слои для более эффективного рендеринга.
   Браузер объединяет слои и отображает окончательное изображение на экране.
- Обработка JavaScript
   JavaScript может изменять DOM и CSSOM, что может привести к повторному рендерингу (repaint) или перерасчету (reflow).
   Браузер обрабатывает JavaScript, который может блокировать рендеринг, если он не выполнен асинхронно.


# HTML

### Отличие блочных и строчных элементов

#### Строчные

`<span>`, `<a/>`, `<img/>`

- ширина зависит от содержимого
- Нельзя задать ширину и высоту
- Не переносится на новую строку
- Может содержать в себе только контент и другие строчные элементы

#### Блочные

`<div>`, `<p>` , `<ul>`, `<ol>`, `<h1>`…`<h6>`

- по умолчанию занимают всю ширину страницы
- начинаются с новой строки
- могут содержать в себе другие блочные или строчные элементы

### Структура HTML

```html

<doctype html> - тип документа
    <html> - вся страница
    <head> - основная инфа (заголовок, кодировка, мета инфа, подключение стилей)
    </head>
    <body> - содержание страницы
    </body>
    </html>
```

### Мета теги

Мета-теги в HTML используются для предоставления информации о веб-странице для поисковых систем и браузеров. Они
помещаются в раздел <head> вашего HTML-документа. Вот некоторые из наиболее распространенных мета-тегов:

- `<meta charset="UTF-8">` - Определяет кодировку символов для веб-страницы. Рекомендуется использовать кодировку UTF-8
  для поддержки всех символов и языков.
- `<meta name="viewport" content="width=device-width, initial-scale=1.0">` - Управляет сжатием и масштабированием
  веб-страницы на мобильных устройствах.
- `<meta name="description" content="Описание вашей страницы">` - Предоставляет краткое описание содержимого вашей
  страницы. Это описание часто отображается в результатах поиска.
- `<meta name="keywords" content="ключевое слово 1, ключевое слово 2, ...">` - Указывает ключевые слова или фразы,
  связанные с вашей страницей. Этот тег менее важен для поисковых систем сегодня, но все же может быть полезен.
- `<meta name="author" content="Имя автора">` - Указывает имя автора веб-страницы.
- `<meta http-equiv="refresh" content="5; URL=http://example.com">` - Позволяет автоматически перенаправить пользователя
  на другую страницу через указанное количество секунд.

Они могут быть полезны для оптимизации сайта, для поисковых систем и предоставления полезной информации о веб-странице.

### Семантическая верстка

Семантическая верстка - это подход к разметке, которая опирается на смысловое предназначение и логическую структуру
документа,
чтобы сделать приложение доступным. Например, с помощью скринридера, человек с особенностями может ориентироваться по
сайту
Чтобы поисковики выдавали результат выше

Примеры тегов:

- `<header>` - шапка сайта
- `<main>` - основное содержимое
- `<footer>` - подвал сайта
- `<nav>` - навигация по сайту (ссылки)
- `<section>` - для разделения на секции. Обязательный дочерний элемент - заголовок
- `<article>` - для статей, записей, новостей. Обязательный дочерний элемент - заголовок
- `<asade>` - боковая панель сайта

### Медиа-Запросы

Медиа-запросы в HTML и CSS используются для определения стилей и разметки, которые должны применяться в зависимости от
характеристик устройства или экрана пользователя. Это позволяет создавать адаптивные веб-сайты, которые выглядят и
функционируют оптимально на различных устройствах.

Медиа-запросы в HTML обычно применяются с помощью атрибута media в теге `<link>` или `<style>`. Например:

HTML

```html

<link rel="stylesheet" media="screen and (max-width: 768px)" href="small.css">
```

- В данном примере стиль, определенный в файле "small.css", будет применяться только на экранах с шириной до 768
  пикселей.

Также медиа-запросы могут быть использованы внутри CSS для определения различных стилей для разных устройств. Например:

CSS

```css
@media screen and (max-width: 768px) {
    body {
        background-color: lightblue;
    }
}
```

Этот код задает светло-голубой фон для тела страницы, только если ширина экрана меньше или равна 768 пикселям.

### Какие браузеры поддерживают HTML5?

Практически все браузеры, но можно проверить совместимость версий языка с браузера на
сайте [caniuse.com](https://caniuse.com/)

### Почему важно указывать атрибут `alt` для `img`?

Атрибут `alt` устанавливает альтернативный текст для изображений. Например, у браузера отключена загрузка изображений,
вместо него будет текстовая информация.

### Для чего нужны Data атрибуты?

Data атрибуты позволяют хранить дополнительную информацию в стандартных элементах html

### Что такое Canvas?

`Canvas` - это HTML элемент, который представляет собой область, на которой можно рисовать графику с помощью JavaScript.
Он предоставляет API для создания и управления изображениями, анимацией и интерактивными элементами, такими как линии,
формы, текст и т. д. Canvas позволяет разработчикам создавать динамический и интерактивный контент с помощью
программного кода.

---

# CSS (Cascade Style Sheet)

### Единицы измерения

- `px` - абсолютные
- `em` - относительно размера шрифта родителя
- `rem` - относительно размера шрифта HTML
- `vm` - относительно размеров экрана
- `vh` - относительно размеров экрана

### Что такое псевдоклассы?

Псевдокласс в CSS — это ключевое слово, добавленное к селектору, которое определяет его особое состояние. Нужен для
интерактива элементов.

### Какие есть псевдоклассы?

- `:hover` - наведение курсором на элемент
- `:focus` - состояние фокуса. Выбранный элемент выделяется
- `:active` - выделение элемента при нажатии
- `:visited` - меняет цвет, если на элемент уже нажимали
- `:disabled` - если задан одноименный атрибут кнопке, то применится этот псевдокласс, после `:hover` делает кнопку
  неактивной

### Для чего нужны псевдоэлементы?

Для декорации

### Какие есть псевдоэлементы?

- `::after` - вставляет содержимое _**после**_ элемента
- `::before` - вставляет содержимое _**до**_ элемента
  _**Прим.:**_ Обязательное свойство для этих псевдоэлементов - `content: ""`
- `::first-letter` - первая буква с индивидуальными стилями
- `::first-line` - первая строка с индивидуальными стилями

### Вес селекторов от меньшего к большему

1. Тег
2. class
3. class тег (вложенность)
4. id
5. `!important`
6. атрибут HTML _**style**_
7. атрибут HTML _**style `!important`**_

## Position

- `static` - по умолчанию
- `relative` - устанавливается относительно его изначального положения.
- `absolute` - позиционируется относительно странице, как бы выдергиваясь из контекста. Если родительскому блоку
  установить `position: relative`, то блок с `position: absolute` будет перемещен относительно родительского блока
- `fixed` - так же как и `position: absolute` вырывает блок из потока и фиксируется относительно окна браузера
- `sticky` - гибрид `position: static` и `position: fixed`, блок статичен, но как только скрол достигает границу блока,
  он фиксируется и прибивается как в случае `position: fixed`

## Display

Свойство, которое определяет, как элемент должен быть показан в документе

- `block` - элемент показывается как блочный. Из строчного можно сделать блочный и к нему применятся свойства как у
  блочного
- `inline` - элемент показывается как строчный
- `inline-block` - ведет себя как строчный элемент, но указывая св-ва блочного элемента, они применяются к нему (ширина,
  высота, отступы)
- `none` - удаляет блок, как будто бы его и не было
- `flex` - элементы отрисовываются в ряд относительно их контейнера, к которому применен `flex`. Сам контейнер остается
  блочным.
- `inline-flex` - подобен `inline-block`
- `grid`

### Display flex

К `flex` можно применить сво-во `justify-content`, которое определяет выравнивание вдоль основной оси. По
умолчанию `justify-content:flex`. Также есть значения:

- `flex-start` - определяет адаптивность всех элементов под самый высокий элемент. Занимает столько сколько нужно и
  прижимает их к верху контейнера
- `flex-end` - то же что и `flex-start`, но прижимает к низу контейнера
- `center` - становится по центру относительно самого высокого эл-та
- `flex-wrap` - если эл-там не хватает места в контейнере, они смещаются ниже. Адаптация `nowrap` отменяет
  адаптацию. `wrap-reverse` так же как и `wrap`, но перемещение будет задом на перед.
- `space-between` -
- `space-around` - Пространство с каждой стороны эл-та (лево\право)
- `align-items` - определяет поведение вдоль поперечной оси (по оси столбца). По умолчанию `align-items:stretch`.
  Элементы подстраиваются под высоту самого высокого эл-та.
- `align-content` - тип выравнивания строк внутри flex-контейнера по поперечной оси при наличии свободного пространства.
- `order` (цифра) - определяет порядок элементов. От меньшего к большему.
- `flex-grow` (цифра) - задаёт коэффициент роста для заданного числа

### Display grid

- `inline-grid` - формирует сетку как строчный элемент
- `grid-template-columns` - определяет размеры grid-колонок. Можно указывать в `px` (точный размер), в `px` и `fr` (
  остаточная ширина), `repeat` (число колонок, px(размер, ширина))
- `grid-template-rows` - определяет размеры grid-строк. Можно указывать в `px` (точный размер), в `px` и `fr` (
  остаточная высота), `repeat` (число строк, px(размер, высота))
- `gap` - задаёт отступы между столбцами и строками
- `align-items` - выравнивает вдоль оси столбца
- `align-content` - выравнивает сетку вдоль оси колонки
- `justify-items` - выравнивает содержимое вдоль оси строки
- `justify-content` - выравнивает сетку вдоль оси строки
- `grid-auto-flow` - `row` заполняет строки по очереди, `column` заполняет столбцы по очереди
- `justify-self` - выравнивает содержимое эл-та вдоль оси строки
- `align-self` - выравнивает содержимое эл-та вдоль оси столбца

### Разница между `flexbox` и `grid`

- `flexbox` позиционирует эл-ты в одном направлении, строке или колонке
- `grid` позиционирует эл-ты в двумерной системе, то есть одновременно и в строке и в колонке.

### display:table

- `display:table`
- `display:table-row`
- `display:table-header-group`
- `display:table-row-group`
- `display:table-footer-group`
- `display:table-column`
- `display:table-column-group`
- `display:table-ceil`
- `display:table-caption`
-

### Разница display: none и visibility: hidden

- `display: none` полностью скрывает элемент со страницы и всё выглядит так, как если бы его вообще не было
- `visibility: hidden` просто делает элемент невидимым, но сохраняет занимаемое им место

### z-index

`z-index` меняет положение по оси Z. Чем больше индекс, тем выше будет находиться эл-т

### Для чего нужен `box-sizing:border-box`?

На размер блока ничего не будет влиять. Border, padding и пр. будут идти внутрь, а контент будет уменьшаться.

### Отцентровка

- по горизонтали: text-align:center
- по вертикали ???

## Препроцессоры

### В чем отличие препроцессора от постпроцессора?

Препроцессоры CSS и постпроцессоры CSS - это инструменты, используемые для упрощения и оптимизации разработки CSS. Они
выполняют разные функции:

#### Препроцессоры CSS:

- Язык: Препроцессоры CSS (например, Sass, Less, Stylus) представляют собой расширения стандартного CSS и обычно имеют
  собственный синтаксис и возможности.
- Функциональность: Они предлагают дополнительные функции, такие как переменные, миксины (шаблоны стилей), операторы,
  вложенность правил и многое другое. Это позволяет разработчикам писать более модульный и эффективный CSS.
- Трансформация: Препроцессоры преобразуют код на своем синтаксисе в обычный CSS до его использования в веб-приложении
  или сайте.
- Дополнительные инструменты: Они часто включают в себя командную строку или графический интерфейс для компиляции кода и
  проверки ошибок.

#### Постпроцессоры CSS:

- CSS-инструмент: Постпроцессоры CSS (например, Autoprefixer, CSSNano, PostCSS) работают непосредственно с обычным CSS,
  который написан разработчиками.
- Функциональность: Они предлагают дополнительные возможности для оптимизации CSS, такие как автоматическое добавление
  вендорных префиксов, удаление неиспользуемого кода, сжатие и объединение файлов CSS и т.д.
- Трансформация: Постпроцессоры преобразуют обычный CSS для оптимизации и улучшения его производительности.
- Расширяемость: Они предоставляют возможность использования различных плагинов и расширений для настройки процесса
  обработки CSS.

В целом, препроцессоры CSS используются для написания более удобного и модульного кода CSS, в то время как
постпроцессоры CSS используются для оптимизации и улучшения производительности обычного CSS.

### Какую проблему решают препроцессоры и зачем они нужны?

- С помощью препроцессора можно указать переменную в которой будет храниться св-во, и далее использовать жту переменную.
  И в случае когда свойство поменялось, сделать это можно только в переменной. В остальные места подтянется.
- Можно использовать _**import**_, то есть в один файл подтянуть все остальные файлы CSS, и на выходе получить только
  один файл который подгружается `@include`
- В обычном CSS нужно указываться родительский блок и его вложенность. При использовании препроцессора можно этого
  избежать. Т.е. написать один раз род. блок и вкладывать в него элементы.
- _**Миксины**_ (Mixin) - примесь стилей позволяет сделать блок силей, которые могут быть неоднократно использованы.

### Миксины

`@mixin <имя миксина> {параметры}
p{@include имя;}`

```scss
@mixin mixinName($color, $width) {
  border: {
    color: $color;
    width: $width;
  };
}

p {
  @include mixinName(red, 2px);
}
```

### БЭМ (Блок, Элемент, Модификатор)

Методология разработки веб-интерфейсов, которая предлагает способ организации и структурирования кода. Она помогает
сделать код более понятным, модульным и легко расширяемым.

В БЭМ вся верстка разбивается на независимые блоки, которые могут быть повторно использованы. Каждый блок состоит из
элементов, которые являются частью блока и не могут существовать вне него. Также у блока могут быть модификаторы,
которые меняют его внешний вид или поведение.

Пример:

Представим, что у нас есть блок "Кнопка". Внутри него у нас будет элемент "Иконка" и модификатор "Длинная", который
меняет размер кнопки.

```html

<div class="button"> Кнопка <i class="button__icon"></i></div>
```

```css
.button {
    display: inline-block;
    padding: 10px;
    background-color: blue;
    color: white;
}

.button__icon {
    display: inline-block;
    width: 20px;
    height: 20px;
    background-color: white;
}

.button_long {
    width: 200px;
}
```

Теперь мы можем использовать блок "Кнопка" в разных местах на сайте, а также легко менять его внешний вид или добавлять
новые модификаторы.
Таким образом, БЭМ помогает организовать код веб-интерфейсов, делая его более понятным и гибким.

### Подключение скрипта в HTML:

```html
<!DOCTYPE html>
<html>
<head>
    <script src="script.js"></script>
</head>
<body>
</body>
</html>
```

В этом примере скрипт "script.js" будет подключен в секции <head> документа HTML.

Внешний скрипт:

```js
alert("Hello, world!");
```

В этом примере скрипт "script.js" содержит одну команду - выводит предупреждение с текстом "Hello, world!".

Встроенный скрипт:

```html

<script>
    alert("Hello, world!");
</script>
```

В этом примере скрипт находится непосредственно внутри тега <script>.

Атрибут "defer":

```html

<script src="script.js" defer></script>
```

В этом примере скрипт "script.js" будет загружен параллельно с HTML, но выполнится только после загрузки документа.

Атрибут "async":

```html

<script src="script.js" async></script>
```

Скрипт "script.js" будет загружен параллельно с HTML и выполнится сразу после загрузки, независимо от состояния загрузки
документа.

### async, defer

- async и defer - это атрибуты, которые можно добавлять к элементам <script> в HTML. Они позволяют управлять способом
  загрузки и выполнения внешних скриптов.
- async: Указывает браузеру загружать скрипт асинхронно. Это означает, что браузер будет продолжать обработку
  HTML-документа, не останавливаясь на загрузке и выполнении скрипта. Как только скрипт загружен, он будет выполнен в
  том порядке, в котором был указан (если не указан атрибут defer) и без ожидания других ресурсов страницы. Если на
  странице несколько скриптов с атрибутом async, выполнение будет происходить в порядке загрузки.
- defer: Указывает браузеру загружать скрипт отложенно. Это означает браузер будет продолжать обработку HTML-документа,
  как и с атрибутом async, но выполнение скрипта будет отложено до тех пор, пока вся страница не будет полностью
  загружена. В случае наличия нескольких скриптов с атрибутом defer, выполнение будет происходить в том порядке, в
  котором были указаны в HTML-документе.
  Использование async и defer позволяет улучшить производительность загрузки страницы, так как скрипты могут загружаться
  параллельно с другими ресурсами и не задерживают рендеринг страницы. Однако, необязательно каждый скрипт помечать
  асинхронным или отложенным - в зависимости от конкретных требований страницы и его взаимодействия с другими элементами
  можно выбирать самостоятельно.

### Способы центрирования

Существуют разные способы центрирования объектов или текста на веб-странице или в документе. Некоторые из них включают в
себя:

#### Центрирование по горизонтали:

- С помощью свойства text-align: center; для элементов с дисплеем block.
- Использование свойства margin: 0 auto; для блочных элементов с заданной шириной.
- Использование свойства flex и его свойства justify-content: center; для контейнера с дисплеем flex.
-

#### Центрирование по вертикали:

- Использование свойств display: flex; и align-items: center; для контейнера.
- Позиционирование объекта абсолютно с помощью свойства top и transform: translateY(-50%);.
- Использование свойства line-height с фиксированым значением и задание высоты блока.
-

#### Центрирование обоими способами:

-Использование свойств flexbox и grid для создания гибкой и адаптивной верстки.
-Использование свойства position: absolute; и комбинации свойств top, left, right, bottom, transform с значениями 50%.
-Использование псевдоэлемента ::before или ::after и комбинации свойств position, top, left, right, bottom с значениями
50%.

---

# JavaScript

## Общее

### Отличия var, let, const

- var - глобальная область видимости, можно вызвать до её определения (hoisting)
- let - область видимости блочная, то есть где она объявлена, там и доступна. Вызывать можно только после её
  определения, иначе будут ошибки. Можно переопределить
- const - нельзя переопределить

### Как создать объект в js?

- через синтаксис «конструктор объекта» (ключевое слово `new`)

```javascript
let user = new Object()
```

- через синтаксис «литерал объекта»

```javascript
let user = {} // свойство - пара «ключ:значение»
```

### Отличие между while и for

- for принимает в себя 3 параметра - начальное значение, условие, шаг
- while выполняется пока принимаемое значение `boolean` не станет `false`

### Способы для сравнения объектов

- `JSON.stringify` - конвертирует объекты в строку и сравнивает.
  Но если свойства объектов идут не в одном порядке, то сравнение вернет false
- с помощью библиотеки __lodash_, есть метод `_.isEqual(объект1, объект2)`

### Основные нововведения в es6

- `let`
- деструктуризация (сразу достаю свойства через `{}`)
- стрелочные функции

### Виды тестирования (необязательно)

- Юнит - тестирование 1 компонента
- Интеграционное - тестирование группы компонентов
- Системное - тестирование всего приложения

### Зачем нужен оператор typeof?

Оператор typeof позволяет определить тип параметра. Он возвращает строку содержащую тип (string, number, object)

Особенности:

- Для null оператор возвращает object
- Для функций оператор возвращает function

### Что такое hoisting?

Hoisting (поднятие) - значит, что объявление переменной или функции перемещается в начало кода

## Функции

### Что такое чистая функция?

Это функция работающая только с теми аргументами, которые в нее передали, и не имеющая side эффектов (сторонних
эффектов). То есть делает, что-то одно

### Что такое замыкание (closures) ?

Замыкание - это функция в функции, то есть внутренняя функция имеет доступ к данным родительской функции.

### Разница между стрелочной и обычной функции.

- В стрелочной функции отсутствует специальный объект `arguments`, содержащий в себе объект со всеми аргументами
  функции.
- Значение `this` внутри обыкновенной функции динамически зависит от контекста вызова. Собственный `this` внутри
  стрелочной функции отсутствует (`undefined`). Но когда стр. ф-ия используется в замыкании, то её `this` будет
  указывать на `this` внешней функции.
- Обычная функция (не анонимная) может быть вызвана до своего определения
- Если в стрелочная функция пишется в одну строку, можно не указывать `return`
- Можно использовать синтаксис стрелочных функций внутри класса. При этом в качестве `this` будет выступать объект
  класса.

### Различие function declaration и function expression

- _function declaration_ - должно содержать ключевое слово function, вызвать можно как до так и после его определения
- _function expression_ - вызвать можно только после определения

### Минусы callback функции

- Функция должна быть выполнена после того, как другая функция завершила выполнение
- Легко потеряться во вложенности

## Операторы

### Разница между операторами «=», «==» и «===»

- `=` оператор присвоения
- `==` является не строгим сравнением (приводит типы данных к 1 виду)
- `===` строгое сравнение данных (без приведения типов)

### Rest & Spread операторы

В чем разница между spread-оператором и rest-оператором?
Операторы spread и rest имеют одинаковый синтаксис (`...`). Разница состоит в том, что с помощью spread мы передаем или
распространяем данные массива на другие данные, а с помощью rest — получаем все параметры функции и помещаем их в
массив (или извлекаем часть параметров).

### Деструктуризация

Что такое деструктуризация объекта (Object Destructuring)?
Деструктуризация — относительно новый способ получения (извлечения) значений объекта или массива. Использование
деструктуризации позволяет сделать код чище и отнимает меньше времени. Синтаксис деструктуризации следующий: заключаем
свойства объекта, которые хотим получить, в фигурные скобки (`{ }`), а если речь идет о массиве — в квадратные
скобки (`[ ]`)

### Оператор "!!"

`!!` (двойное отрицание) приводит значение справа от него к логическому значению.

## Типы данных

8 типов данных (7 примитивов и 1 непримитив)

- string - строка
- number - число
- boolean - логическое значение true/false
- null - специальное значение, указывает на его отсутствие
- underfined - специальное значение, указывает на то, что значение не установлено
- symbol - уникальное значение, часто применяется для обращения к свойствам сложных объектов
- bigint - очень большое число
- object - комплексный объект, составной тип данных, туда же массивы и функции

### В чем разница null и undefined?

null указывает на отсутствие значения, а undefined на его неопределенность

### Как можно привести одни типы к другим?

Преобразовать можно к string, number, boolean

- явное преобразование

```javascript
const age = 2
String(age) // "2"
```

- неявное с помощью конкатенации значения со строкой
  (к строке приводиться только при сложении)
  В остальных случаях (-, /, *) приравнивается к числу

```javascript
const age = 30 + "2" // "302"
```

### Что такое NaN, как проверить является ли значение NaN?

NaN - not a number (не число), способ проверки через функцию

```javascript
isNaN(значение)
```

## Контекст

### Какое значение имеет this?

This - ключевое слово, которое указывает на текущий контекст выполнения кода, если использовать this внутри какого-либо
объекта, то this ссылается именно на этот объект

### Методы bind, call, apply - привязывают контекст к какой-либо функции

- в метод `call()` параметры функции передаются через запятую
- в метод `apply()` в массив
- отличие `bind()` от `call()` и `apply()`, в том что `bind()` не вызывает функцию, он создает новую функцию с новым
  контекстом.
  Параметры передаются через запятую, как и в `call()`.

### Мемоизация

### debounce & throttle

### Shadow DOM

### Prototype

## Массивы

### Методы массивов

#### Методы вставки\удаления

- `pop()` - удаляет последний элемент массива
- `push()` - добавляет элемент в начало массива
- `shift()` - удаляет первый элемент массива
- `unshift()` - добавляет элемент в начало массива

##### Какой из этих методов быстрее и почему?

`push`/`pop` быстрее потому что работают с элементами в конце массива, а `unshift`/`shift` с его началом и для этих
операций требуется переиндексация всего массива

##### Что если использовать вместо pop/shift/splice _delete_?

На месте удаленных элементов останется `undefined`

#### Методы для работы со всеми элементами массива

- `map()` - применяет к каждому элементу массива какое-то действие. Возвращает новый измененный массив, не изменяя
  предыдущий
- `forEach()` - изменяет исходный массив
- `filter()` - фильтрует массив по какому-то условию. Возвращает новый массив
- `find()` - ищет элемент по условию. Выведет только первый найденный элемент, даже если условию удовлетворяют несколько
  элементов
- `findIndex()` - ищет индекс по условию. Возвращает индекс искомого элемента, либо возвращает -1, если условие не
  выполнено, то есть элемент не найден
- `indexOf()` - ищет элемент в массиве и возвращает его индекс
- `reduce()` - применяет функцию reducer к каждому элементу массива, возвращая одно результирующее значение. Принимает 4
  аргумента, один из них аккумулятор - это необязательный параметр, используемый в качестве первого аргумента при первом
  вызове функции callback. Например можно посчитать сумму чисел в массиве
- `includes()` - проверяет, содержит ли массив определенный элемент. Возвращает true, если элемент найден в массиве,
  иначе возвращает false.

#### Другие методы

- `splice()` - удаляет элемент из массива и добавляет на его место другой. Не возвращает новый массив
- `slice()` - обрезает массив

## Строки

### Методы строк

- `toUpperCase()`, `toLowerCase()` (смена регистра)
- `indexOf()`, `includes()` (поиск символов в строке)
- `slice()`, `substring()` (обрезка строки)
- `replace()`, `replaceAll()` (замена символов в строке
- `repeat()` (повторение строки несколько раз)
- `trim()` (удаление лишних пробелов)

## Объекты

### Что такое Object.freeze?

`Object.freeze()` замораживает объект: это значит, что он предотвращает добавление новых свойств к объекту, удаление
старых свойств из объекта и изменение существующих свойств или значения их атрибутов перечисляемости, настраиваемости и
записываемости. В сущности, объект становится эффективно неизменным. Метод возвращает замороженный объект.

### Что такое Object.seal?

`Object.seal()` запечатывает объект, предотвращая добавление новых свойств к объекту и делая все существующие свойства
не настраиваемыми. Значения представленных свойств всё ещё могут изменяться, поскольку они остаются записываемыми

### В чем разница между методами Object.freeze и Object.seal?

Разница заключается в том, что при использовании метода `Object.freeze()` мы не можем менять или редактировать свойства
объекта, а при использовании `Object.seal()` такая возможность имеется, но в обоих случаях нельзя удалять и добавлять новые поля

## ООП

### ООП - объектно ориентированное программирование (парадигма - это способ мышления, способ восприятия чего-либо)

- **Абстракция** - выделение важного для решения задач
- **Инкапсуляция** - сокрытие сложной реализации под понятным интерфейсом
- **Наследование** - перенятие свойств и методов одного класса другим
- **Полиморфизм** - возможность метода работать с аргументом и его наследниками

### Классы

- Наследование классов, super()
- Статические свойства и методы
- Приватные и защищённые методы и свойства

## Events

### Event, event listener, handler

Объект Event описывает событие, произошедшее на странице. Одной из причин возникновения событий являются действия
пользователя, такие как клики мышкой MouseEvent или ввод с клавиатуры KeyboardEvent

- **Event listener** - прослушиватель событий
- **Handler** - обработчик событий

### Что такое делегирование событий???

### Что такое распространение события (Event Propagation)?

Когда какое-либо событие происходит в элементе DOM, оно на самом деле происходит не только в нем. Событие
«распространяется» от объекта Window до вызвавшего его элемента (event.target). При этом событие последовательно
пронизывает (затрагивает) всех предков целевого элемента. Распространение события имеет три стадии или фазы:

- Фаза погружения (захвата, перехвата) — событие возникает в объекте Window и опускается до цели события через всех ее
  предков.
- Целевая фаза — это когда событие достигает целевого элемента.
- Фаза всплытия — событие поднимается от event.target, последовательно проходит через всех его предков и достигает
  объекта Window.

### Что такое всплытие события?

Когда событие происходит в элементе DOM, оно затрагивает не только этот элемент. Событие «всплывает» (подобно пузырьку
воздуха в воде), переходит от элемента, вызвавшего событие (event.target), к его родителю, затем поднимается еще выше, к
родителю родителя элемента, пока не достигает объекта Window.

### Что такое погружение события?

Когда событие происходит в элементе DOM, оно происходит не только в нем. В фазе погружения событие опускается от объекта
Window до цели события через всех его предков.

### В чем разница между методами event.preventDefault() и event.stopPropagation()?

- event.preventDefault() отключает поведение элемента по умолчанию. Если использовать этот метод в элементе form, то он
  предотвратит отправку формы (submit). Если использовать его в contextmenu, то контекстное меню будет отключено
- event.stopPropagation() отключает распространение события (его всплытие или погружение).

### Как узнать об использовании метода event.preventDefault()?

Для этого мы можем использовать свойство event.defaulPrevented, возвращающее логическое значение, служащее индикатором
применения к элементу метода event.preventDefault.

## Ассинхронный JS

### Зачем нужна асинхронность и какую проблему она решает?

Асинхронность - это способ взаимодействия с данными, когда не знаешь, в какой точно момент появятся данные.

Если код работает синхронно, то пользователь не сможет взаимодействовать со страницей, пока не придет результат.

Асинхронный код позволяет избежать этого. Он убирает блокирующую операцию из основного потока, пока она где-то
продолжает выполняться, а обработчик может идти дальше

### Event loop

Event loop - это событийный цикл, бесконечный цикл в котором JS ожидает задачи, выполняет их и ждет новые.
У него есть свой порядок, выполнения:

- сначала выполняются все макрозадачи (callstack выполнение кода от первой строчки до последней)
- вызывает все, что есть в очереди микрозадач (microtask queue - promise (than/catch/finally))
- вызывает все, что есть в очереди вызовов (callback queue - `setTimeOut()`, `setInterval()`)

### Что такое Promise ?

Promise (обещание) - это объект в JavaScript, представляющий результат асинхронной операции. Promise может находиться в
одном из трех состояний:

- pending (ожидание) - начальное состояние, когда Promise ещё не выполнен и не отклонен.
- fulfilled (выполнено) - состояние, когда Promise успешно выполнен, и берёт на себя ответственность вернуть результат.
- rejected (отклонено) - состояние, когда Promise отклонен из-за ошибки, и берёт на себя ответственность вернуть причину
  этой ошибки.

Promise используется для упрощения работы с асинхронными операциями, такими как запросы к серверу или задержка
выполнения кода. Вместо использования старого стиля с функциями обратного вызова (callback), синхронный код теперь может
быть записан асинхронно с цепочкой промисов и вызовами `.then()` и `.catch()`.

Методы promise:

- `.then()`: Обрабатывает успешное выполнение асинхронной операции. Когда промис завершается успешно (в состоянии "
  fulfilled"), функция, переданная в `.then()`, вызывается с результатом промиса. В `.then()` можно цепочкой добавлять
  последовательные асинхронные операции для обработки.
- `.catch()`: Обрабатывает возникшие ошибки во время выполнения промиса. Если промис завершается с ошибкой (состояние "
  rejected"), функция, переданная в `.catch()`, вызывается с информацией об ошибке. Добавляется после `.then()` для
  обработки ошибок.
- `.finally()`: Выполняет заданную функцию вне зависимости от результата промиса — успешного или ошибочного. Обычно
  используется для выполнения определенных действий, которые должны произойти в любом случае, например, очистка ресурсов
  или скрытие индикатора загрузки.
-

### Выполнение и обработка результатов с помощью .then(), .catch(), .finally()

### Методы промисов Promise.all(),

- `.allSettled()`: ,
- `.any()`: ,
- `.race()`: ,
- `.resolve()`: ,
- `.reject()`:

### Создание промисов new Promise()

### Основные понятия async/await. Зачем нужны async/await?

С `then()`/`catch()`/`finally()` - вызовы растут вправо, это не удобно. А с `async`/`await` - все идет линейно, код
становить более читабельным

### Обработка ошибок с использованием блока:

- `try`:
- `catch`:
- `finally`:

### Запросы fetch vs axios

### Модули (ES, commonJS)

### throw-

### Геттеры и сеттеры

### Разобраться почему вредно ставить await в return, например return await request(...);

### Разница setTimeOut и setInterval

- `setTimeOut()` - позволяет вызвать функцию один раз через определенный интервал времени
- `setInterval()` - позволяет вызывать функцию регулярно, повторяя вызов через определенный интервал времени

### Объекты Set и Map

### Объекты WeakSet и WeakMap

### События

- Введение в браузерные события
- Делегирование
- Распространение (всплытие, погружение) событий

## Сборщики проектов

### Для чего webpack и какие задачи он выполняет

Webpack - это сборщик модулей. Он анализирует модули приложения, создает граф зависимостей, затем собирает модули в
правильном порядке в один или более бандл (bundle), на который может ссылаться файл (`index.html`)

Если загрузить скрипт, зависящий от React, до загрузки самого React, приложение сломается. Webpack - решает эти задачи.
Не нужно беспокоиться о последовательности подключения всех скриптов

---

# Сети

### Запросы

- GET - получает - безопасный и идемпотентный. Все данные в URL, тело запроса пустое.
- POST - изменяет состояние сервера (создает какие-то сущности). Не безопасный и не идемпотентный запрос. Все данные в
  теле, URL пустой
- PUT - обновляет сущность на сервере. Не безопасный и идемпотентный. Данные могут передаваться как в теле так и в URL
- DELETE - удаляет сущность. Не безопасный и не идемпотентный. Данные могут передаваться как в теле так и в URL

Идемпотентный - это при повторном вызове запроса ответ будет тем же

---

# React - библиотека

## Общее

### Что такое React?

React — это библиотека JavaScript с открытым исходным кодом, созданная Facebook для разработки сложных интерактивных
пользовательских интерфейсов в веб- и мобильных приложениях. Основная цель React — создание компонентов
пользовательского интерфейса; их часто называют просто «V» (View) в архитектуре «MVC».

### Что такое JSX?

JSX является расширением синтаксиса JavaScript и поставляется с полной функциональностью JavaScript. JSX производит
«элементы» React. Вы можете встроить любое выражение JavaScript в JSX, заключив его в фигурные скобки. После компиляции
выражения JSX становятся обычными объектами JavaScript. Это означает, что вы можете использовать JSX внутри операторов
if и циклов for, назначать его переменным, принимать в качестве аргументов и возвращать из функций.

### Что такое контролируемые компоненты?

В контролируемом компоненте данные формы обрабатываются состоянием внутри компонента. Состояние внутри компонента служит
«единственным источником правды» для элементов ввода, которые отображаются компонентом. Нам не нужен элемент формы на
странице, чтобы компонент был контролируемым компонентом.

### Что такое некотролируемые компоненты?

Неконтролируемые компоненты действуют больше как традиционные элементы формы HTML. Данные для каждого элемента ввода
хранятся в DOM, а не в компоненте. Вместо того чтобы писать обработчик событий для всех ваших обновлений состояния, вы
используете ref для получения значений из DOM.

### Фазы жизненного цикла компонентов React

- **Инициализация** - на этом этапе компонент React готовит установку начального состояния и параметров по умолчанию
- **Монтирование** - компонент React готов для монтирования в DOM браузера. Этот этап охватывает методы жизненного
  цикла `componentWillMount` и `componentDidMount`
- **Обновление** - на этом этапе компонент обновляется двумя способами, отправляя свойства и обновляя состояние. Этот
  этап охватывает методы жизненного цикла `shouldComponentUpdate`, `componentWillUpdate`, `componentDidUpdate`
- **Размонтирование** - на этом последнем этапе компонент не нужен и отключается из DOM браузера, этот этап включает
  метод `componentWillUnmount`

Дополнительно:

- componentWillMount- перед рендерингом, в основном для настройки компонента
- render- процесс рендеринга
- componentDidMount- уведомляет, про то, что компонент соединен с DOM
  деревом
- componentWillReceiveProps- уведомляет, про то, что приходят новые
  входящие свойства в компонент
- shouldComponentUpdate- возвращает true или false и служит для
  оптимизации. Решает, нужно ли делать ре-рендеринг
- componentWillUpdate- уведомляет, что компонент будет обновлен
- componentDidUpdate- уведомляет, что компонент был обновлен
- componentWillUnmount- используется для удаления слушателей и очистки
  компонента. Вызывается перед удалением компонента

### Что такое Props?

Props это короткое название Properties в React. Они только для чтения. Они всегда передаются вниз от родителя к ребёнку.
Дочерний компонент никогда не может передать prop обратно родителю. Это помогает поддерживать однонаправленный поток
данных и обычно используется для рендера динамически генерируемых данных.

### Что такое состояние React?

State - это объект, которые определяют рендеринг и поведение компонентов. Он мутабельный и создает динамические и
интерактивные компоненты. После изменения state происходит ре-рендер компонента

### Для чего нужны keys в React?

Ключи используются для идентификации уникальных виртуальных элементов DOM с соответствующими данными, управляющими
пользовательским интерфейсом. Они помогают React оптимизировать рендеринг, перерабатывая все существующие элементы в
DOM. Эти ключи должны быть уникальными числами или строками, используя которые React просто переупорядочить элементы, а
не перерисовывает их. Это повышает производительность приложения.

### Для чего в React используется Virtual Dom?

Самые затратные операции в JS - это работа с DOM-дерево, это такие функции как `document.querySelector()`
или `getElementById()`.

То есть каждый раз, когда мы берем JS и делаем доступ до DOM-дерево, то требуется некоторое количество времени для того,
чтобы найти и получить в JS.

Когда приложение интерактивное и много взаимодействий, оно может тормозить.

Virtual Dom - легковесный JS объект, который представляет копию реального DOM-дерева

Нужен он для оптимизации взаимодействия с DOM

## Хуки

Хуки - это функции, с помощью которых можно подцепиться к состоянию и методам жизненного цикла React из функциональных
компонентов

### Основные хуки

- `useState()` - управление состояние функционального компонента React

```jsx
const [state, setState] = useState() // state - переменная, которая хранит само состояние
// setState - функция, которая меняет состояние
// (initialState) - начальное значение состояния
```

- `useEffect()` - используя этот хук мы говорим React сделать что-то после рендера.
  React запомнит это и вызовет функцию после того, как внесет изменения в DOM

```jsx
useEffect(() => {
}, []) // [] - зависимости, при изменении которых срабатывает рендер
```

- `useContext()` - получение контекста в дочерних элементах
- `useHistory()`
- `useLocation()`

#### Из сторонних библиотек

- `useTable()` из React.Table
- `useForm()`

#### Преимущество хуков

Хуки позволяют повторно использовать логику состояния, писать код проще, эффективнее использовать функционал, упрощает
разработку за счет декларативности

### Для чего нужен ref?

`ref` - это атрибут в React, который помогает хранить ссылку на определенный элемент или компонент, который будет
возвращен функцией конфигурации рендеринга компонентов.

Нужен:

- для интеграции со сторонами библиотеки
- когда нужно работать с фокусом, выделить текст или работа с медиа
- Для запуска императивной анимации (Императивная анимация работает в браузере основным потоком.)

### Что такое Context?

Контекст позволяет передавать данные через дерево компонентов без необходимости передавать пропсы на промежуточных
уровнях.

## Паттерны

### MVC

Архитектурный паттерн в котором приложение представляется в виде 3 слоёв:

- **_Model_** - слой данных. В него входят базы данных.
- **_View_** - слой представления. В него входит весь фронт-энд.
- **_Controller_** - слой управления данными. Он же бэк-энд

### Что такое компоненты высшего порядка (High Order Component)?

HOC это кастомный компонент, который оборачивает другой компонент. Может принять любой динамически предоставленный
дочерний компонент, но они не будут изменять или копировать любое поведение из своих компонентов. Можно сказать что HOC
это чистый компонент.

#### Действия с HOC

- Переиспользование кода, логики
- Абстракция и манипуляция state
- Манипуляция с props

### Flux

Flux - это архитектурный паттерн, который обеспечивает однонаправленный поток данных. Он контролирует производные данные
и обеспечивает связь между несколькими компонентами с использованием центрального хранилища, которые имеет полномочия
для всех данных. Любое обновление данных должно происходить только здесь. Flux обеспечивает стабильность приложения и
уменьшает ошибки во время выполнения.

### Разница между Презентационным и Контейнер компонентом?

- Презентационный - “как вещи выглядят”. Нужен для создания интерфейса. Работает на входящих параметрах
- Контейнер - “как вещи работают”. Обладают состоянием, подключены к Flux или Redux

---

# Redux

### Что такое Redux?

Это предсказуемый контейнер состояний для приложений JavaScript, который используется для управления состоянием всего
приложения.

_**Примечание:**_ Приложения, разработанные с помощью Redux, легко тестируются и могут работать в разных средах,
демонстрируя согласованное поведение.

### Принципы Redux?

- Единый источник правды: Состояние всего приложения хранится в дереве объектов/состояний в одном хранилище. Единое
  дерево состояний облегчает отслеживание изменений и отладку или проверку приложения.
- State только для чтения: Единственный способ изменить state вызвать Action. Action - это просто объект JS описывающий
  изменение.
- Изменения сделаны чистыми функциями: Чтобы указать, как дерево состояний трансформируется действиями, вам нужны чистые
  функции.

### Принцип "Единый источник правды" в Redux

Redux использует Store для хранения всего состояния приложения в одном месте. Таким образом все состояние компонента
хранится в Store, и они получают обновления от самого Store. Единое дерево состояний облегчает отслеживание изменений во
времени и отладку или проверку приложения.

## Компоненты Redux

- Action - Объект, который описывает что происходит
- Reducer - Место, где определяется как state изменится
- Store - Состояние/Объект дерева всего приложения которое хранится в Store
- View - Отображает данные, предоставленные Store

### Как Actions определяются в Redux?

Action в React должны иметь свойство type которое показывает тип Action. Они должны быть определены как строковая
константа, можно добавить еще свойства. В Redux actions создаются при помощи функции которая возвращает типа и данные.

### Объясните роль Reducer?

Reducers это чистые функции которые описывают как состояние приложения изменяется в ответ на Action. Reducer работает
принимая прежнее состояние и действие, а затем возвращает новое состояние. Он определяет, какое обновление необходимо
выполнить, основываясь на типе действия, а затем возвращает новые значение. Возвращает предыдущее состояние если не
нужно выполнять никаких действий.

### Каково назначение Store в Redux?

Store - это JavaScript объект, который содержит состояние приложения и предоставляет несколько вспомогательных методов
для доступа к состоянию, рассылает действия и регистрирует слушателей. Все дерево состояний/объектов приложения
сохраняется в одном хранилище.

В результате Redux очень просто и предсказуем. Мы можем передать промежуточное программное обеспечение в хранилище для
обработки данных, а также для ведения журнала различных действий, которые изменяют состояние хранилищ. Все действия
возвращают новое состояние через reducers.

---

# Git

### Разница между merge и rebase?

Merge — это процесс объединения изменений из одной ветви с другой веткой. Это позволяет сохранить историю коммитов и
создать новый коммит, который объединяет изменения из обеих веток.

Rebase — это способ переписать историю ветки так, чтобы она выглядела как непрерывная последовательность коммитов.
Rebase переносит все изменения из одной ветки в другую ветку, создавая новые коммиты. При этом история коммитов
переписывается, что может привести к потере истории или конфликтам при слиянии с другими ветками.

В целом, merge сохраняет историю коммитов, а rebase её переписывает. Merge обычно используется для объединения работы
нескольких разработчиков, а rebase — для очистки истории коммитов перед отправкой кода на сервер.

### Почему рекомендуют использовать концепцию git flow?

Git flow — это набор рекомендаций и практик для работы с Git, который помогает организовать процесс разработки
программного обеспечения.

Git flow предлагает использовать несколько веток для разных этапов разработки.
Использование git flow позволяет разработчикам работать над разными задачами одновременно, не мешая друг другу, а также
упрощает процесс выпуска новых версий продукта.

### Назовите основные команды git?

git init — инициализация нового репозитория;
git clone — клонирование существующего репозитория на локальный компьютер;
git add — добавление файлов в индекс (staging area);
git commit — создание коммита с изменениями из staging area;
git status — просмотр состояния репозитория и файлов;
git branch — работа с ветками, создание, переключение и удаление;
git checkout — переключение между ветками или возврат к предыдущему коммиту;
git merge — объединение изменений из одной ветки в другую;
git pull — получение изменений с удалённого репозитория и их слияние с текущей веткой;
git push — отправка изменений с локальной ветки на удалённый репозиторий;
git revert — отмена одного или нескольких последних коммитов;
git log — просмотр истории коммитов.

### Как можно отменить commit?

Чтобы отменить commit в Git, можно использовать команду git revert. Она создаёт новый коммит, который отменяет изменения
предыдущего коммита.

Синтаксис команды:

```git revert <commit-hash>```

где `<commit-hash>` — это хеш коммита, который вы хотите отменить.

Обратите внимание, что после выполнения этой команды история коммитов будет изменена, и вы не сможете вернуться к
предыдущему состоянию проекта.

### merge +решение конфликтов

Git merge — это команда, которая объединяет изменения из одной ветви с другой ветвью. Она позволяет сохранить историю коммитов и создать новый коммит, который объединяет изменения из обеих веток.

Однако иногда при слиянии ветвей могут возникать конфликты. Это происходит, когда изменения в одной ветке затрагивают те же строки кода, что и изменения в другой ветке. В этом случае Git не может автоматически объединить изменения и требует вмешательства разработчика.

### fetch и разница с pull

Git fetch — это команда, которая загружает изменения из удалённого репозитория в локальный. Она не вносит изменений в текущую ветку, а просто обновляет информацию о том, что произошло в удалённом репозитории.

Синтаксис команды:

git fetch <remote>
где <remote> — это имя удалённого репозитория.

Пример:

git fetch origin
Эта команда загрузит все изменения из репозитория origin в ваш локальный репозиторий.

### stash

Stash — это команда, которая временно сохраняет изменения в вашем рабочем каталоге, чтобы вы могли переключиться на другую ветку или выполнить другую задачу. После того как вы закончите работу над другой веткой или задачей, вы можете применить сохранённые изменения обратно к текущей ветке.

### rebase

Rebase — это процесс перемещения серии коммитов из одной ветки в другую. Это позволяет вам переписать историю вашей ветки так, чтобы она выглядела более линейной и последовательной. Rebase может быть полезен, когда вы хотите объединить несколько веток или удалить ненужные коммиты.

### squash

Squash — это способ объединения нескольких коммитов в один. Это полезно, когда у вас есть серия небольших коммитов, которые можно объединить в один более значимый коммит. Squash также может помочь вам упростить историю вашей ветки.

### reset

Reset — это команда, которая позволяет вам вернуться к предыдущему состоянию вашего репозитория. Вы можете использовать reset для отмены изменений, сделанных в вашей рабочей копии, или для возврата к определённому коммиту.

### revert commit

Revert commit — это действие, которое отменяет изменения, внесённые определённым коммитом. Revert создаёт новый коммит, который отменяет все изменения предыдущего коммита.

### cherry-pick

Cherry-pick — это возможность взять отдельный коммит из одной ветви и применить его к другой ветви. Это может быть полезно, если вы хотите добавить определённый набор изменений в свою текущую ветку.

### patch

Patch — это файл, содержащий изменения кода. В Git патчи используются для обмена изменениями между разработчиками или для создания новых версий программного обеспечения.

### Git submodules

Git submodules — это функция Git, которая позволяет включать в проект другие проекты как подмодули. Подмодули имеют свою собственную историю и могут быть обновлены независимо от основного проекта.

---

# TypeScript

### Назовите плюсы и минусы TS?

Плюсы:

- строгая типизация
- интерфейсы
- ооп
- компилятор реализует подход fail fast (получаешь обр. связь в момент написания кода а не в момент тестирования)
- очень хорошая поддержка TS в редакторах кода (советы, ошибки, и кододополнение намного лучше чем в JS)

Минусы:

- нужно больше учить (выше порог входа)
- Существующий код сложно перенести на TS
- Код из библиотек бывает сложно читать из-за обилия дженериков и прочего

_**Прим:**_ Некоторые библиотеки и фреймворки (например Angular) работают только с TS

### Почему нерекомендуется использовать any?

Тогда TS превращается в JS, тк «убивается» типизация

### Для чего нужны дженерики?

### разница между type и interface?

- `type` не может расширяться в отличие от `interface`
- `type` может быть объявлен только 1 раз. Если интерфейс объявляется 2 раза, то его свойства «сливаются»
- Тип не может быть реализован, только объявлен. Интерфейс нужно реализовывать

### Зачем нужен тип unknow?

`unknown` является безопасной (с точки зрения типов) версией типа `any`.
Когда свойство объявлено как `any`, у него становится поведение как у обычного JS поля. Если поле объявлено
как `unknown`, у него нельзя вызвать никакого метода или свойства без явной проверки `unknown` на конкретный тип (
через `typeof`)

### Для чего нужен enum и какая разница с union типом?

### В каких случаях можно использовать картеж? (Дописать)

Это про tuple

### Встроенные типы

### Enums

### Структуры данных

### Модификаторы доступа

### Utility Types

### TypeScript & React

### Абстрактные классы