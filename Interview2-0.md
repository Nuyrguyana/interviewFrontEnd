# Общие вопросы

***

## Способы хранения данных в браузере

| Тип                | Описание                                                                                                                                                                                                                    | Срок хранения                                                                                                                                                                                   | Объем                                                |
|--------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|------------------------------------------------------|
| **Cookie**         | Небольшие файлы данных, которые хранятся на стороне клиента и отправляются на сервер с каждым HTTP-запросом                                                                                                                 | Куки могут иметь заданный срок жизни. Если срок не установлен, они будут храниться до закрытия браузера (сессионные куки). Если установлен срок, куки будут храниться до истечения этого срока. | Обычно ограничены 4KB на куки.                       |
| **localStorage**   | Хранилище, позволяющее сохранять данные в формате ключ-значение на стороне клиента.                                                                                                                                         | Данные в localStorage сохраняются бесконечно, до тех пор, пока пользователь не удалит их вручную или не очистит кеш браузера.                                                                   | Обычно ограничено 5-10MB (в зависимости т браузера). |
| **sessionStorage** | Похож на localStorage, но данные сохраняются только на время текущей сессии.                                                                                                                                                | Данные исчезают, когда вкладка или браузер закрывается.                                                                                                                                         | Обычно также ограничено 5-10MB.                      |
| **Indexed DB**     | более сложный механизм хранения данных, который позволяет хранить большие объемы структурированных данных. Он поддерживает транзакции и может работать с объектами, что делает его подходящим для более сложных приложений. | Данные в IndexedDB хранятся бессрочно, пока пользователь не удалит их вручную или не очистит кэш браузера.                                                                                      |

## Процессы, которые происходят в браузере, когда изменяются элементы в веб-приложении

| Тип           | Описание                                                                                                                                                                                                                                | Пример                                                                                                                                                                          |
|---------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| **Reflow**    | Процесс пересчета расположения элементов на странице. Он происходит, когда изменяются размеры элементов на странице, например, при изменении размера окна браузера, изменении шрифта или добавлении новых элементов на страницу         | Когда пользователь изменяет размер окна браузера, браузер пересчитывает расположение всех элементов на странице, чтобы они соответствовали новым размерам окна.                 |
| **Repaint**   | Процесс обновления отображения элементов на странице без изменения их расположения. Он происходит, когда изменяются свойства элементов, влияющие только на их внешний вид, например, цвет фона, границы или текст.                      | Когда пользователь наводит курсор мыши на кнопку, она может изменять цвет фона или стиль, но ее расположение остается прежним.                                                  |
| **Composite** | Процесс, когда браузер отображает изменения на странице после Reflow и Repaint. Он происходит после того, как браузер заканчивает обновление отображения элементов на странице, и объединяет их в единую картинку для показа на экране. | Когда пользователь кликает на кнопку, браузер отображает изменения, связанные с Reflow и Repaint, и затем объединяет их в одну единую картинку, которая отображается на экране. |

## Виды клиент-серверного взаимодействия

| Тип                                        | Описание                                                                                                                                                                                                                                       | Пример                                                                                                        |
|--------------------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|---------------------------------------------------------------------------------------------------------------|
| **HTTP (HyperText Transfer Protocol)**     | Стандартный протокол для передачи данных в интернете. Клиент отправляет запрос серверу, и сервер отвечает данными (например, веб-страницей).                                                                                                   | Загрузка веб-страницы через браузер.                                                                          |
| **Long Polling**                           | Клиент отправляет запрос серверу и ожидает ответа. Если сервер не имеет новых данных, он не отвечает сразу, а удерживает соединение открытым до тех пор, пока не появятся новые данные. После получения данных клиент отправляет новый запрос. | Чат-приложения, где клиент ждет новых сообщений от сервера.                                                   |
| **WebSocket**                              | Протокол, который устанавливает постоянное соединение между клиентом и сервером для двусторонней передачи данных в реальном времени. Это позволяет обмениваться сообщениями без необходимости повторных запросов.                              | Онлайн-игры или приложения для обмена сообщениями, где требуется мгновенный обмен данными.                    |
| **SSE (Server-Sent Events)**               | Технология, позволяющая серверу отправлять обновления клиенту через однонаправленное соединение. Клиент устанавливает соединение, и сервер может отправлять данные, когда они становятся доступными.                                           | Уведомления о новых сообщениях или обновлениях на веб-странице.                                               |
| **REST (Representational State Transfer)** | Архитектурный стиль, использующий стандартные HTTP-методы (GET, POST, PUT, DELETE) для взаимодействия с ресурсами на сервере. Каждый ресурс имеет свой уникальный URL.                                                                         | API для работы с данными, где клиент может запрашивать, добавлять или изменять информацию.                    |
| **GraphQL**                                | Язык запросов для API, который позволяет клиенту запрашивать только те данные, которые ему нужны, вместо получения фиксированного набора данных.                                                                                               | Клиент может запрашивать конкретные поля из сложной структуры данных, сокращая объем передаваемой информации. |
| **gRPC (Google Remote Procedure Call)**    | Протокол удаленного вызова процедур, который использует HTTP/2 для связи между клиентом и сервером. Поддерживает двустороннюю потоковую передачу данных и более эффективное сериализованное представление данных.                              | Микросервисные архитектуры, где сервисы общаются друг с другом.                                               |

## Что такое CORS?

**CORS (Cross-Origin Resource Sharing)** — это механизм безопасности в вебе, который позволяет браузерам контролировать,
какие ресурсы могут загружаться с других доменов.

- Безопасность: CORS помогает предотвратить атаки, такие как межсайтовый скриптинг (XSS).
- Заголовки: Сервер использует заголовки, такие как Access-Control-Allow-Origin, чтобы указать, какие домены могут
  получать доступ к его ресурсам.
- Запросы: CORS применим только к запросам, сделанным с помощью JavaScript в браузере, и не влияет на обычные
  HTTP-запросы, сделанные с серверов.

## Критические этапы рендеринга

**Рендеринг веб-страницы** — это процесс, в ходе которого браузер преобразует HTML, CSS и JavaScript в визуальное
представление, которое пользователь видит на экране. Этот процесс можно разделить на несколько критических этапов:

- **Загрузка ресурсов**\
  Браузер отправляет HTTP-запросы на сервер для получения HTML-документа и других ресурсов (CSS, JavaScript, изображения
  и т. д.).
  Полученные ресурсы загружаются в браузер.
- **Парсинг HTML**\
  Браузер начинает парсить (анализировать) HTML-документ и строит дерево элементов (DOM — Document Object Model).
  Каждая HTML-тег становится узлом в дереве.
- **Парсинг CSS**\
  Одновременно с парсингом HTML браузер парсит CSS-файлы и встроенные стили, создавая дерево стилей (CSSOM — CSS Object
  Model).
  Это дерево содержит информацию о стилях, применяемых к элементам DOM.
- **Создание рендер-дерева**\
  Браузер объединяет DOM и CSSOM для создания рендер-дерева.
  Рендер-дерево содержит только те узлы, которые должны быть отображены на экране, и включает в себя информацию о стилях
  для каждого элемента.
- **Расчет геометрии (layout)**\
  На этом этапе браузер вычисляет размеры и положение каждого элемента на странице.
  Этот процесс называется layout или reflow.
- **Рисование (painting)**\
  Браузер начинает рисовать элементы на экране, начиная с фона и заканчивая текстом и изображениями.
  Этот процесс называется painting.
- **Составление слоев (compositing)**\
  В современных браузерах элементы могут быть разделены на слои для более эффективного рендеринга.
  Браузер объединяет слои и отображает окончательное изображение на экране.
- **Обработка JavaScript**\
  JavaScript может изменять DOM и CSSOM, что может привести к повторному рендерингу (repaint) или перерасчету (reflow).
  Браузер обрабатывает JavaScript, который может блокировать рендеринг, если он не выполнен асинхронно.

# HTML

***

## Отличие блочных и строчных элементов

|Тип|описание|примеры|
|-|-|-|
|**Строчные**|- ширина зависит от содержимого <br>- Нельзя задать ширину и высоту<br>- Не переносится на новую строку<br>- Может содержать в себе только контент и другие строчные элементы|`<span>`<br> `<a/>`<br> `<img/>`<br> `<button>`<br> `<input>`|
|**Блочные**|- по умолчанию занимают всю ширину страницы <br>- начинаются с новой строки<br>- могут содержать в себе другие блочные или строчные элементы|`<div>`<br> `<p/>`<br> `<ul>`<br> `<ol>`<br> `<h1>`…`<h6>`|

## Структура HTML

```html

<doctype html> - тип документа
    <html> - вся страница
    <head> - основная инфа (заголовок, кодировка, мета инфа, подключение стилей)
    </head>
    <body> - содержание страницы
    </body>
    </html>
```

## Мета теги

Мета-теги в HTML используются для предоставления информации о веб-странице для поисковых систем и браузеров. Они помещаются в раздел <head> вашего HTML-документа. Вот некоторые из наиболее распространенных мета-тегов:

- `<meta charset="UTF-8">` - Определяет кодировку символов для веб-страницы. Рекомендуется использовать кодировку UTF-8
  для поддержки всех символов и языков.
- `<meta name="viewport" content="width=device-width, initial-scale=1.0">` - Управляет сжатием и масштабированием
  веб-страницы на мобильных устройствах.
- `<meta name="description" content="Описание вашей страницы">` - Предоставляет краткое описание содержимого вашей
  страницы. Это описание часто отображается в результатах поиска.
- `<meta name="keywords" content="ключевое слово 1, ключевое слово 2, ...">` - Указывает ключевые слова или фразы,
  связанные с вашей страницей. Этот тег менее важен для поисковых систем сегодня, но все же может быть полезен.
- `<meta name="author" content="Имя автора">` - Указывает имя автора веб-страницы.
- `<meta http-equiv="refresh" content="5; URL=http://example.com">` - Позволяет автоматически перенаправить пользователя
  на другую страницу через указанное количество секунд.

Они могут быть полезны для оптимизации сайта, для поисковых систем и предоставления полезной информации о веб-странице.

## Семантическая верстка

**Семантическая верстка** - это подход к разметке, которая опирается на смысловое предназначение и логическую структуру документа, чтобы сделать приложение доступным. Например, с помощью скринридера, человек с особенностями может ориентироваться по
сайту  
Чтобы поисковики выдавали результат выше

Примеры тегов:

- `<header>` - шапка сайта
- `<main>` - основное содержимое
- `<footer>` - подвал сайта
- `<nav>` - навигация по сайту (ссылки)
- `<section>` - для разделения на секции. Обязательный дочерний элемент - заголовок
- `<article>` - для статей, записей, новостей. Обязательный дочерний элемент - заголовок
- `<asade>` - боковая панель сайта

## Медиа-Запросы

Медиа-запросы в HTML и CSS используются для определения стилей и разметки, которые должны применяться в зависимости от
характеристик устройства или экрана пользователя. Это позволяет создавать адаптивные веб-сайты, которые выглядят и
функционируют оптимально на различных устройствах.

Медиа-запросы в HTML обычно применяются с помощью атрибута media в теге `<link>` или `<style>`. Например:

HTML

```html

<link rel="stylesheet" media="screen and (max-width: 768px)" href="small.css">
```

- В данном примере стиль, определенный в файле "small.css", будет применяться только на экранах с шириной до 768
  пикселей.

Также медиа-запросы могут быть использованы внутри CSS для определения различных стилей для разных устройств. Например:

CSS

```css
@media screen and (max-width: 768px) {
    body {
        background-color: lightblue;
    }
}
```

Этот код задает светло-голубой фон для тела страницы, только если ширина экрана меньше или равна 768 пикселям.

## Какие браузеры поддерживают HTML5?

Практически все браузеры, но можно проверить совместимость версий языка с браузера на
сайте [caniuse.com](https://caniuse.com/)

## Почему важно указывать атрибут `alt` для `<img/>`?

Атрибут `alt` устанавливает альтернативный текст для изображений. Например, у браузера отключена загрузка изображений,
вместо него будет текстовая информация.

## Для чего нужны Data атрибуты?

**Data** атрибуты позволяют хранить дополнительную информацию в стандартных элементах html

## Что такое Canvas?

`Canvas` - это HTML элемент, который представляет собой область, на которой можно рисовать графику с помощью JavaScript.
Он предоставляет API для создания и управления изображениями, анимацией и интерактивными элементами, такими как линии,
формы, текст и т. д. Canvas позволяет разработчикам создавать динамический и интерактивный контент с помощью
программного кода.

# CSS

***

## Единицы измерения

- `px` - абсолютные
- `em` - относительно размера шрифта родителя
- `rem` - относительно размера шрифта HTML
- `vm` - относительно размеров экрана
- `vh` - относительно размеров экрана

## Что такое псевдоклассы?

**Псевдокласс в CSS** — это ключевое слово, добавленное к селектору, которое определяет его особое состояние. Нужен для
интерактива элементов.

## Какие есть псевдоклассы?

- `:hover` - наведение курсором на элемент
- `:focus` - состояние фокуса. Выбранный элемент выделяется
- `:active` - выделение элемента при нажатии
- `:visited` - меняет цвет, если на элемент уже нажимали
- `:disabled` - если задан одноименный атрибут кнопке, то применится этот псевдокласс, после `:hover` делает кнопку
  неактивной

## Для чего нужны псевдоэлементы?

Для декорации

## Какие есть псевдоэлементы?

- `::after` - вставляет содержимое _**после**_ элемента
- `::before` - вставляет содержимое _**до**_ элемента
  _**Прим.:**_ Обязательное свойство для этих псевдоэлементов - `content: ""`
- `::first-letter` - первая буква с индивидуальными стилями
- `::first-line` - первая строка с индивидуальными стилями

## Вес селекторов от меньшего к большему

1. Псевдоэлементы // 1
2. Тег // 1
3. Псевдоклассы // 10
4. class // 10
5. id // 10
6. `!important`
7. атрибут HTML _**style**_ // 1000
8. атрибут HTML _**style `!important`**_

## Position

- `static` - по умолчанию
- `relative` - устанавливается относительно его изначального положения.
- `absolute` - позиционируется относительно странице, как бы выдергиваясь из контекста. Если родительскому блоку
  установить `position: relative`, то блок с `position: absolute` будет перемещен относительно родительского блока
- `fixed` - так же как и `position: absolute` вырывает блок из потока и фиксируется относительно окна браузера
- `sticky` - гибрид `position: static` и `position: fixed`, блок статичен, но как только скрол достигает границу блока,
  он фиксируется и прибивается как в случае `position: fixed`

## Display

Свойство, которое определяет, как элемент должен быть показан в документе

- `block` - элемент показывается как блочный. Из строчного можно сделать блочный и к нему применятся свойства как у
  блочного
- `inline` - элемент показывается как строчный
- `inline-block` - ведет себя как строчный элемент, но указывая св-ва блочного элемента, они применяются к нему (ширина,
  высота, отступы)
- `none` - удаляет блок, как будто бы его и не было
- `flex` - элементы отрисовываются в ряд относительно их контейнера, к которому применен `flex`. Сам контейнер остается
  блочным.
- `inline-flex` - подобен `inline-block`
- `grid`

## Display flex

К `flex` можно применить сво-во `justify-content`, которое определяет выравнивание вдоль основной оси. По
умолчанию `justify-content:flex`. Также есть значения:

- `flex-start` - определяет адаптивность всех элементов под самый высокий элемент. Занимает столько сколько нужно и
  прижимает их к верху контейнера
- `flex-end` - то же что и `flex-start`, но прижимает к низу контейнера
- `center` - становится по центру относительно самого высокого эл-та
- `flex-wrap` - если эл-там не хватает места в контейнере, они смещаются ниже. Адаптация `nowrap` отменяет
  адаптацию. `wrap-reverse` так же как и `wrap`, но перемещение будет задом на перед.
- `space-between` -
- `space-around` - Пространство с каждой стороны эл-та (лево\право)
- `align-items` - определяет поведение вдоль поперечной оси (по оси столбца). По умолчанию `align-items:stretch`.
  Элементы подстраиваются под высоту самого высокого эл-та.
- `align-content` - тип выравнивания строк внутри flex-контейнера по поперечной оси при наличии свободного пространства.
- `order` (цифра) - определяет порядок элементов. От меньшего к большему.
- `flex-grow` (цифра) - задаёт коэффициент роста для заданного числа

## Display grid

- `inline-grid` - формирует сетку как строчный элемент
- `grid-template-columns` - определяет размеры grid-колонок. Можно указывать в `px` (точный размер), в `px` и `fr` (
  остаточная ширина), `repeat` (число колонок, px(размер, ширина))
- `grid-template-rows` - определяет размеры grid-строк. Можно указывать в `px` (точный размер), в `px` и `fr` (
  остаточная высота), `repeat` (число строк, px(размер, высота))
- `gap` - задаёт отступы между столбцами и строками
- `align-items` - выравнивает вдоль оси столбца
- `align-content` - выравнивает сетку вдоль оси колонки
- `justify-items` - выравнивает содержимое вдоль оси строки
- `justify-content` - выравнивает сетку вдоль оси строки
- `grid-auto-flow` - `row` заполняет строки по очереди, `column` заполняет столбцы по очереди
- `justify-self` - выравнивает содержимое эл-та вдоль оси строки
- `align-self` - выравнивает содержимое эл-та вдоль оси столбца

## Разница между `flexbox` и `grid`

- `flexbox` позиционирует эл-ты в одном направлении, строке или колонке
- `grid` позиционирует эл-ты в двумерной системе, то есть одновременно и в строке и в колонке.

## display:table

- `display:table`
- `display:table-row`
- `display:table-header-group`
- `display:table-row-group`
- `display:table-footer-group`
- `display:table-column`
- `display:table-column-group`
- `display:table-ceil`
- `display:table-caption`

## Разница display: none и visibility: hidden

- `display: none` полностью скрывает элемент со страницы и всё выглядит так, как если бы его вообще не было
- `visibility: hidden` просто делает элемент невидимым, но сохраняет занимаемое им место

## z-index

`z-index` меняет положение по оси Z. Чем больше индекс, тем выше будет находиться эл-т

## Для чего нужен `box-sizing:border-box`?

На размер блока ничего не будет влиять. Border, padding и пр. будут идти внутрь, а контент будет уменьшаться.

## Препроцессоры CSS и постпроцессоры CSS

Препроцессоры CSS и постпроцессоры CSS - это инструменты, используемые для упрощения и оптимизации разработки CSS.
- Препроцессоры CSS используются для написания более удобного и модульного кода CSS
- Постпроцессоры CSS используются для оптимизации и улучшения производительности обычного CSS.

|Тип|Инструмент|Функциональность|Трансформация|Дополнительные инструмента|
|-|-|-|-|-|
| **Препроцессоры CSS**  | Препроцессоры CSS (например, Sass, Less, Stylus) представляют собой расширения стандартного CSS и обычно имеют собственный синтаксис и возможности. | Они предлагают дополнительные функции, такие как переменные, миксины (шаблоны стилей), операторы, вложенность правил и многое другое. Это позволяет разработчикам писать более модульный и эффективный CSS. | Препроцессоры преобразуют код на своем синтаксисе в обычный CSS до его использования в веб-приложении или сайте.| Они часто включают в себя командную строку или графический интерфейс для компиляции кода и проверки ошибок.|
| **Постпроцессоры CSS** | Постпроцессоры CSS (например, Autoprefixer, CSSNano, PostCSS) работают непосредственно с обычным CSS, который написан разработчиками. | Они предлагают дополнительные возможности для оптимизации CSS, такие как автоматическое добавление вендорных префиксов, удаление неиспользуемого кода, сжатие и объединение файлов CSS и т.д. | Постпроцессоры преобразуют обычный CSS для оптимизации и улучшения его производительности.| Они предоставляют возможность использования различных плагинов и расширений для настройки процесса обработки CSS.|

## Какую проблему решают препроцессоры и зачем они нужны?

- С помощью препроцессора можно указать переменную в которой будет храниться св-во, и далее использовать эту переменную.
  И в случае когда свойство поменялось, сделать это можно только в переменной. В остальные места подтянется.
- Можно использовать _**import**_, то есть в один файл подтянуть все остальные файлы CSS, и на выходе получить только
  один файл который подгружается `@include`
- В обычном CSS нужно указываться родительский блок и его вложенность. При использовании препроцессора можно этого
  избежать. Т.е. написать один раз род. блок и вкладывать в него элементы.
- _**Миксины**_ (Mixin) - примесь стилей позволяет сделать блок силей, которые могут быть неоднократно использованы.

## Миксины

`@mixin <имя миксина> {параметры}
p{@include имя;}`

```scss
@mixin mixinName($color, $width) {
  border: {
    color: $color;
    width: $width;
  };
}

p {
  @include mixinName(red, 2px);
}
```

# JavaScript

***

# TypeScript

***

# React

***

# Redux

***

# Git

***
