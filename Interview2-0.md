# Общие вопросы

***

## Способы хранения данных в браузере

|Тип|Описание|Срок хранения|Объем|
|-|-|-|-|
|**Cookie**|Небольшие файлы данных, которые хранятся на стороне клиента и отправляются на сервер с каждым HTTP-запросом|Куки могут иметь заданный срок жизни. Если срок не установлен, они будут храниться до закрытия браузера (сессионные куки). Если установлен срок, куки будут храниться до истечения этого срока.|Обычно ограничены 4KB на куки.|
|**localStorage**|Хранилище, позволяющее сохранять данные в формате ключ-значение на стороне клиента.|Данные в localStorage сохраняются бесконечно, до тех пор, пока пользователь не удалит их вручную или не очистит кеш браузера.|Обычно ограничено 5-10MB (в зависимости т браузера).|
|**sessionStorage**|Похож на localStorage, но данные сохраняются только на время текущей сессии.|Данные исчезают, когда вкладка или браузер закрывается.|Обычно также ограничено 5-10MB.|
|**Indexed DB**|более сложный механизм хранения данных, который позволяет хранить большие объемы структурированных данных. Он поддерживает транзакции и может работать с объектами, что делает его подходящим для более сложных приложений.|Данные в IndexedDB хранятся бессрочно, пока пользователь не удалит их вручную или не очистит кэш браузера.|

## Процессы, которые происходят в браузере, когда изменяются элементы в веб-приложении

|Тип|Описание|Пример|
|-|-|-|
| **Reflow**   | Процесс пересчета расположения элементов на странице. Он происходит, когда изменяются размеры элементов на странице, например, при изменении размера окна браузера, изменении шрифта или добавлении новых элементов на страницу        | Когда пользователь изменяет размер окна браузера, браузер пересчитывает расположение всех элементов на странице, чтобы они соответствовали новым размерам окна.                |
| **Repaint**  | Процесс обновления отображения элементов на странице без изменения их расположения. Он происходит, когда изменяются свойства элементов, влияющие только на их внешний вид, например, цвет фона, границы или текст.                     | Когда пользователь наводит курсор мыши на кнопку, она может изменять цвет фона или стиль, но ее расположение остается прежним.                                                 |
| **Composite** | Процесс, когда браузер отображает изменения на странице после Reflow и Repaint. Он происходит после того, как браузер заканчивает обновление отображения элементов на странице, и объединяет их в единую картинку для показа на экране. | Когда пользователь кликает на кнопку, браузер отображает изменения, связанные с Reflow и Repaint, и затем объединяет их в одну единую картинку, которая отображается на экране. |

## Виды клиент-серверного взаимодействия

| Тип                                        | Описание                                                                                                                                                                                                                                       | Пример                                                                                                        |
|--------------------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|---------------------------------------------------------------------------------------------------------------|
| **HTTP (HyperText Transfer Protocol)**     | Стандартный протокол для передачи данных в интернете. Клиент отправляет запрос серверу, и сервер отвечает данными (например, веб-страницей).                                                                                                   | Загрузка веб-страницы через браузер.                                                                          |
| **Long Polling**                           | Клиент отправляет запрос серверу и ожидает ответа. Если сервер не имеет новых данных, он не отвечает сразу, а удерживает соединение открытым до тех пор, пока не появятся новые данные. После получения данных клиент отправляет новый запрос. | Чат-приложения, где клиент ждет новых сообщений от сервера.                                                   |
| **WebSocket**                              | Протокол, который устанавливает постоянное соединение между клиентом и сервером для двусторонней передачи данных в реальном времени. Это позволяет обмениваться сообщениями без необходимости повторных запросов.                              | Онлайн-игры или приложения для обмена сообщениями, где требуется мгновенный обмен данными.                    |
| **SSE (Server-Sent Events)**               | Технология, позволяющая серверу отправлять обновления клиенту через однонаправленное соединение. Клиент устанавливает соединение, и сервер может отправлять данные, когда они становятся доступными.                                           | Уведомления о новых сообщениях или обновлениях на веб-странице.                                               |
| **REST (Representational State Transfer)** | Архитектурный стиль, использующий стандартные HTTP-методы (GET, POST, PUT, DELETE) для взаимодействия с ресурсами на сервере. Каждый ресурс имеет свой уникальный URL.                                                                         | API для работы с данными, где клиент может запрашивать, добавлять или изменять информацию.                    |
| **GraphQL**                                | Язык запросов для API, который позволяет клиенту запрашивать только те данные, которые ему нужны, вместо получения фиксированного набора данных.                                                                                               | Клиент может запрашивать конкретные поля из сложной структуры данных, сокращая объем передаваемой информации. |
| **gRPC (Google Remote Procedure Call)**    | Протокол удаленного вызова процедур, который использует HTTP/2 для связи между клиентом и сервером. Поддерживает двустороннюю потоковую передачу данных и более эффективное сериализованное представление данных.                              | Микросервисные архитектуры, где сервисы общаются друг с другом.                                               |
## Методы HTTP
HTTP (HyperText Transfer Protocol) использует несколько стандартных методов для выполнения различных операций с ресурсами на сервере. Вот основные методы HTTP:

> Идемпотентный - это при повторном вызове запроса ответ будет тем же

|Тип|Описание| Безопасность                                   | Иденпотентность                        | Данные                                                      |
|-|-|------------------------------------------------|----------------------------------------|-------------------------------------------------------------|
|GET|Используется для запроса данных с сервера| Безопасный          | Идемпотентный                          | Передаются в URL (в виде параметров запроса).               |
|POST| Используется для отправки данных на сервер, например, для создания нового ресурса.| Не безопасный              | Не идемпотентный                       | Обычно передаются в теле запроса.                           |
|PUT|Используется для обновления существующего ресурса или создания нового, если его не существует.| Не безопасный| Идемпотентный                          | Передаются в теле запроса.                                  |
|DELETE| Используется для удаления ресурса на сервере.| Не безопасный| Идемпотентный (если ресурс уже удален) | Обычно передаются в URL (идентификатор удаляемого ресурса). |
|PATCH|Используется для частичного обновления ресурса.| Не безопасный              | Не обязательно, зависит от реализации. | Передаются в теле запроса.                                  |
|HEAD|Запрашивает метаданные ресурса, не возвращая сам ресурс.|Безопасный| Идемпотентный                          | Не передает данных в теле, только в заголовках.             |
|OPTIONS|Используется для получения информации о доступных методах для конкретного ресурса.|                                Безопасный| Идемпотентный                          | Не передает данных в теле, только в заголовках.                                                            |
|TRACE|Метод используется для диагностики и отладки. Он возвращает содержимое запроса, который был отправлен на сервер, позволяя клиенту увидеть, как запрос был обработан.|   Безопасный                                             |Идемпотентный|Передает данные в теле запроса, возвращая их в ответе.|
|CONNECT|Метод используется для установки туннеля к серверу, чаще всего через прокси-сервер. Он позволяет создать соединение, например, для использования SSL (HTTPS) через HTTP-прокси.|Не безопасный  | Не идемпотентный(каждый вызов может устанавливать новое соединение)                     |Не передает данных в теле запроса, используется для создания соединения.|

## HTTP статус-кодов:

- Информационные ответы (100 – 199)
- Успешные ответы (200 – 299)
- Сообщения о перенаправлении (300 – 399)
- Ошибки клиента (400 – 499)
- Ошибки сервера (500 – 599)

## Что такое CORS?

**CORS (Cross-Origin Resource Sharing)** — это механизм безопасности в вебе, который позволяет браузерам контролировать,
какие ресурсы могут загружаться с других доменов.

- Безопасность: CORS помогает предотвратить атаки, такие как межсайтовый скриптинг (XSS).
- Заголовки: Сервер использует заголовки, такие как Access-Control-Allow-Origin, чтобы указать, какие домены могут
  получать доступ к его ресурсам.
- Запросы: CORS применим только к запросам, сделанным с помощью JavaScript в браузере, и не влияет на обычные
  HTTP-запросы, сделанные с серверов.

## Критические этапы рендеринга

**Рендеринг веб-страницы** — это процесс, в ходе которого браузер преобразует HTML, CSS и JavaScript в визуальное
представление, которое пользователь видит на экране. Этот процесс можно разделить на несколько критических этапов:

- **Загрузка ресурсов**\
  Браузер отправляет HTTP-запросы на сервер для получения HTML-документа и других ресурсов (CSS, JavaScript, изображения
  и т. д.).
  Полученные ресурсы загружаются в браузер.
- **Парсинг HTML**\
  Браузер начинает парсить (анализировать) HTML-документ и строит дерево элементов (DOM — Document Object Model).
  Каждая HTML-тег становится узлом в дереве.
- **Парсинг CSS**\
  Одновременно с парсингом HTML браузер парсит CSS-файлы и встроенные стили, создавая дерево стилей (CSSOM — CSS Object
  Model).
  Это дерево содержит информацию о стилях, применяемых к элементам DOM.
- **Создание рендер-дерева**\
  Браузер объединяет DOM и CSSOM для создания рендер-дерева.
  Рендер-дерево содержит только те узлы, которые должны быть отображены на экране, и включает в себя информацию о стилях
  для каждого элемента.
- **Расчет геометрии (layout)**\
  На этом этапе браузер вычисляет размеры и положение каждого элемента на странице.
  Этот процесс называется layout или reflow.
- **Рисование (painting)**\
  Браузер начинает рисовать элементы на экране, начиная с фона и заканчивая текстом и изображениями.
  Этот процесс называется painting.
- **Составление слоев (compositing)**\
  В современных браузерах элементы могут быть разделены на слои для более эффективного рендеринга.
  Браузер объединяет слои и отображает окончательное изображение на экране.
- **Обработка JavaScript**\
  JavaScript может изменять DOM и CSSOM, что может привести к повторному рендерингу (repaint) или перерасчету (reflow).
  Браузер обрабатывает JavaScript, который может блокировать рендеринг, если он не выполнен асинхронно.

## Для чего webpack и какие задачи он выполняет

Webpack - это сборщик модулей. Он анализирует модули приложения, создает граф зависимостей, затем собирает модули в
правильном порядке в один или более бандл (bundle), на который может ссылаться файл (`index.html`)

Если загрузить скрипт, зависящий от React, до загрузки самого React, приложение сломается. Webpack - решает эти задачи.
Не нужно беспокоиться о последовательности подключения всех скриптов

# HTML

***

## Отличие блочных и строчных элементов

|Тип|описание|примеры|
|-|-|-|
|**Строчные**|- ширина зависит от содержимого <br>- Нельзя задать ширину и высоту<br>- Не переносится на новую строку<br>- Может содержать в себе только контент и другие строчные элементы|`<span>`<br> `<a/>`<br> `<img/>`<br> `<button>`<br> `<input>`|
|**Блочные**|- по умолчанию занимают всю ширину страницы <br>- начинаются с новой строки<br>- могут содержать в себе другие блочные или строчные элементы|`<div>`<br> `<p/>`<br> `<ul>`<br> `<ol>`<br> `<h1>`…`<h6>`|

## Структура HTML

```html

<doctype html> - тип документа
    <html> - вся страница
    <head> - основная инфа (заголовок, кодировка, мета инфа, подключение стилей)
    </head>
    <body> - содержание страницы
    </body>
    </html>
```

## Мета теги

Мета-теги в HTML используются для предоставления информации о веб-странице для поисковых систем и браузеров. Они помещаются в раздел <head> вашего HTML-документа. Вот некоторые из наиболее распространенных мета-тегов:

- `<meta charset="UTF-8">` - Определяет кодировку символов для веб-страницы. Рекомендуется использовать кодировку UTF-8
  для поддержки всех символов и языков.
- `<meta name="viewport" content="width=device-width, initial-scale=1.0">` - Управляет сжатием и масштабированием
  веб-страницы на мобильных устройствах.
- `<meta name="description" content="Описание вашей страницы">` - Предоставляет краткое описание содержимого вашей
  страницы. Это описание часто отображается в результатах поиска.
- `<meta name="keywords" content="ключевое слово 1, ключевое слово 2, ...">` - Указывает ключевые слова или фразы,
  связанные с вашей страницей. Этот тег менее важен для поисковых систем сегодня, но все же может быть полезен.
- `<meta name="author" content="Имя автора">` - Указывает имя автора веб-страницы.
- `<meta http-equiv="refresh" content="5; URL=http://example.com">` - Позволяет автоматически перенаправить пользователя
  на другую страницу через указанное количество секунд.

Они могут быть полезны для оптимизации сайта, для поисковых систем и предоставления полезной информации о веб-странице.

## Семантическая верстка

**Семантическая верстка** - это подход к разметке, которая опирается на смысловое предназначение и логическую структуру документа, чтобы сделать приложение доступным. Например, с помощью скринридера, человек с особенностями может ориентироваться по
сайту  
Чтобы поисковики выдавали результат выше

Примеры тегов:

- `<header>` - шапка сайта
- `<main>` - основное содержимое
- `<footer>` - подвал сайта
- `<nav>` - навигация по сайту (ссылки)
- `<section>` - для разделения на секции. Обязательный дочерний элемент - заголовок
- `<article>` - для статей, записей, новостей. Обязательный дочерний элемент - заголовок
- `<asade>` - боковая панель сайта

## Медиа-Запросы

Медиа-запросы в HTML и CSS используются для определения стилей и разметки, которые должны применяться в зависимости от
характеристик устройства или экрана пользователя. Это позволяет создавать адаптивные веб-сайты, которые выглядят и
функционируют оптимально на различных устройствах.

Медиа-запросы в HTML обычно применяются с помощью атрибута media в теге `<link>` или `<style>`. Например:

HTML

```html

<link rel="stylesheet" media="screen and (max-width: 768px)" href="small.css">
```

- В данном примере стиль, определенный в файле "small.css", будет применяться только на экранах с шириной до 768
  пикселей.

Также медиа-запросы могут быть использованы внутри CSS для определения различных стилей для разных устройств. Например:

CSS

```css
@media screen and (max-width: 768px) {
    body {
        background-color: lightblue;
    }
}
```

Этот код задает светло-голубой фон для тела страницы, только если ширина экрана меньше или равна 768 пикселям.

## Какие браузеры поддерживают HTML5?

Практически все браузеры, но можно проверить совместимость версий языка с браузера на
сайте [caniuse.com](https://caniuse.com/)

## Почему важно указывать атрибут `alt` для `<img/>`?

Атрибут `alt` устанавливает альтернативный текст для изображений. Например, у браузера отключена загрузка изображений,
вместо него будет текстовая информация.

## Для чего нужны Data атрибуты?

**Data** атрибуты позволяют хранить дополнительную информацию в стандартных элементах html

## Что такое Canvas?

`Canvas` - это HTML элемент, который представляет собой область, на которой можно рисовать графику с помощью JavaScript.
Он предоставляет API для создания и управления изображениями, анимацией и интерактивными элементами, такими как линии,
формы, текст и т. д. Canvas позволяет разработчикам создавать динамический и интерактивный контент с помощью
программного кода.

# CSS

***

## Единицы измерения

- `px` - абсолютные
- `em` - относительно размера шрифта родителя
- `rem` - относительно размера шрифта HTML
- `vm` - относительно размеров экрана
- `vh` - относительно размеров экрана

## Что такое псевдоклассы?

**Псевдокласс в CSS** — это ключевое слово, добавленное к селектору, которое определяет его особое состояние. Нужен для
интерактива элементов.

## Какие есть псевдоклассы?

- `:hover` - наведение курсором на элемент
- `:focus` - состояние фокуса. Выбранный элемент выделяется
- `:active` - выделение элемента при нажатии
- `:visited` - меняет цвет, если на элемент уже нажимали
- `:disabled` - если задан одноименный атрибут кнопке, то применится этот псевдокласс, после `:hover` делает кнопку
  неактивной

## Для чего нужны псевдоэлементы?

Для декорации

## Какие есть псевдоэлементы?

- `::after` - вставляет содержимое _**после**_ элемента
- `::before` - вставляет содержимое _**до**_ элемента
  _**Прим.:**_ Обязательное свойство для этих псевдоэлементов - `content: ""`
- `::first-letter` - первая буква с индивидуальными стилями
- `::first-line` - первая строка с индивидуальными стилями

## Вес селекторов от меньшего к большему

1. Псевдоэлементы // 1
2. Тег // 1
3. Псевдоклассы // 10
4. class // 10
5. id // 10
6. `!important`
7. атрибут HTML _**style**_ // 1000
8. атрибут HTML _**style `!important`**_

## Position

- `static` - по умолчанию
- `relative` - устанавливается относительно его изначального положения.
- `absolute` - позиционируется относительно странице, как бы выдергиваясь из контекста. Если родительскому блоку
  установить `position: relative`, то блок с `position: absolute` будет перемещен относительно родительского блока
- `fixed` - так же как и `position: absolute` вырывает блок из потока и фиксируется относительно окна браузера
- `sticky` - гибрид `position: static` и `position: fixed`, блок статичен, но как только скрол достигает границу блока,
  он фиксируется и прибивается как в случае `position: fixed`

## Display

Свойство, которое определяет, как элемент должен быть показан в документе

- `block` - элемент показывается как блочный. Из строчного можно сделать блочный и к нему применятся свойства как у
  блочного
- `inline` - элемент показывается как строчный
- `inline-block` - ведет себя как строчный элемент, но указывая св-ва блочного элемента, они применяются к нему (ширина,
  высота, отступы)
- `none` - удаляет блок, как будто бы его и не было
- `flex` - элементы отрисовываются в ряд относительно их контейнера, к которому применен `flex`. Сам контейнер остается
  блочным.
- `inline-flex` - подобен `inline-block`
- `grid`

## Display flex

К `flex` можно применить сво-во `justify-content`, которое определяет выравнивание вдоль основной оси. По
умолчанию `justify-content:flex`. Также есть значения:

- `flex-start` - определяет адаптивность всех элементов под самый высокий элемент. Занимает столько сколько нужно и
  прижимает их к верху контейнера
- `flex-end` - то же что и `flex-start`, но прижимает к низу контейнера
- `center` - становится по центру относительно самого высокого эл-та
- `flex-wrap` - если эл-там не хватает места в контейнере, они смещаются ниже. Адаптация `nowrap` отменяет
  адаптацию. `wrap-reverse` так же как и `wrap`, но перемещение будет задом на перед.
- `space-between` -
- `space-around` - Пространство с каждой стороны эл-та (лево\право)
- `align-items` - определяет поведение вдоль поперечной оси (по оси столбца). По умолчанию `align-items:stretch`.
  Элементы подстраиваются под высоту самого высокого эл-та.
- `align-content` - тип выравнивания строк внутри flex-контейнера по поперечной оси при наличии свободного пространства.
- `order` (цифра) - определяет порядок элементов. От меньшего к большему.
- `flex-grow` (цифра) - задаёт коэффициент роста для заданного числа

## Display grid

- `inline-grid` - формирует сетку как строчный элемент
- `grid-template-columns` - определяет размеры grid-колонок. Можно указывать в `px` (точный размер), в `px` и `fr` (
  остаточная ширина), `repeat` (число колонок, px(размер, ширина))
- `grid-template-rows` - определяет размеры grid-строк. Можно указывать в `px` (точный размер), в `px` и `fr` (
  остаточная высота), `repeat` (число строк, px(размер, высота))
- `gap` - задаёт отступы между столбцами и строками
- `align-items` - выравнивает вдоль оси столбца
- `align-content` - выравнивает сетку вдоль оси колонки
- `justify-items` - выравнивает содержимое вдоль оси строки
- `justify-content` - выравнивает сетку вдоль оси строки
- `grid-auto-flow` - `row` заполняет строки по очереди, `column` заполняет столбцы по очереди
- `justify-self` - выравнивает содержимое эл-та вдоль оси строки
- `align-self` - выравнивает содержимое эл-та вдоль оси столбца

## Разница между `flexbox` и `grid`

- `flexbox` позиционирует эл-ты в одном направлении, строке или колонке
- `grid` позиционирует эл-ты в двумерной системе, то есть одновременно и в строке и в колонке.

## display:table

- `display:table`
- `display:table-row`
- `display:table-header-group`
- `display:table-row-group`
- `display:table-footer-group`
- `display:table-column`
- `display:table-column-group`
- `display:table-ceil`
- `display:table-caption`

## Разница display: none и visibility: hidden

- `display: none` полностью скрывает элемент со страницы и всё выглядит так, как если бы его вообще не было
- `visibility: hidden` просто делает элемент невидимым, но сохраняет занимаемое им место

## z-index

`z-index` меняет положение по оси Z. Чем больше индекс, тем выше будет находиться эл-т

## Для чего нужен `box-sizing:border-box`?

На размер блока ничего не будет влиять. Border, padding и пр. будут идти внутрь, а контент будет уменьшаться.

## Препроцессоры CSS и постпроцессоры CSS

Препроцессоры CSS и постпроцессоры CSS - это инструменты, используемые для упрощения и оптимизации разработки CSS.
- Препроцессоры CSS используются для написания более удобного и модульного кода CSS
- Постпроцессоры CSS используются для оптимизации и улучшения производительности обычного CSS.

|Тип|Инструмент|Функциональность|Трансформация|Дополнительные инструмента|
|-|-|-|-|-|
| **Препроцессоры CSS**  | Препроцессоры CSS (например, Sass, Less, Stylus) представляют собой расширения стандартного CSS и обычно имеют собственный синтаксис и возможности. | Они предлагают дополнительные функции, такие как переменные, миксины (шаблоны стилей), операторы, вложенность правил и многое другое. Это позволяет разработчикам писать более модульный и эффективный CSS. | Препроцессоры преобразуют код на своем синтаксисе в обычный CSS до его использования в веб-приложении или сайте.| Они часто включают в себя командную строку или графический интерфейс для компиляции кода и проверки ошибок.|
| **Постпроцессоры CSS** | Постпроцессоры CSS (например, Autoprefixer, CSSNano, PostCSS) работают непосредственно с обычным CSS, который написан разработчиками. | Они предлагают дополнительные возможности для оптимизации CSS, такие как автоматическое добавление вендорных префиксов, удаление неиспользуемого кода, сжатие и объединение файлов CSS и т.д. | Постпроцессоры преобразуют обычный CSS для оптимизации и улучшения его производительности.| Они предоставляют возможность использования различных плагинов и расширений для настройки процесса обработки CSS.|

## Какую проблему решают препроцессоры и зачем они нужны?

- С помощью препроцессора можно указать переменную в которой будет храниться св-во, и далее использовать эту переменную.
  И в случае когда свойство поменялось, сделать это можно только в переменной. В остальные места подтянется.
- Можно использовать _**import**_, то есть в один файл подтянуть все остальные файлы CSS, и на выходе получить только
  один файл который подгружается `@include`
- В обычном CSS нужно указываться родительский блок и его вложенность. При использовании препроцессора можно этого
  избежать. Т.е. написать один раз род. блок и вкладывать в него элементы.
- _**Миксины**_ (Mixin) - примесь стилей позволяет сделать блок силей, которые могут быть неоднократно использованы.

`@mixin <имя миксина> {параметры}
p{@include имя;}`

```scss
@mixin mixinName($color, $width) {
  border: {
    color: $color;
    width: $width;
  };
}

p {
  @include mixinName(red, 2px);
}
```
## БЭМ (Блок, Элемент, Модификатор)

Методология разработки веб-интерфейсов, которая предлагает способ организации и структурирования кода. Она помогает
сделать код более понятным, модульным и легко расширяемым.

В БЭМ вся верстка разбивается на независимые блоки, которые могут быть повторно использованы. Каждый блок состоит из
элементов, которые являются частью блока и не могут существовать вне него. Также у блока могут быть модификаторы,
которые меняют его внешний вид или поведение.

### Основные понятия

|Блок|Элемент|Модификатор|
|-|-|-|
| Независимый компонент интерфейса, который может быть использован в разных местах. Например, это может быть навигационное меню, кнопка или форма. Пример: menu, button, form. | Часть блока, которая не может существовать отдельно от него. Элементы описывают составные части блока. Пример: menu__item, button__icon, form__input. | Используется для обозначения различных состояний или внешнего вида блока или элемента. Модификаторы позволяют изменять внешний вид или поведение блоков и элементов. Пример: button--primary, menu__item--active, form__input--error. |

### Пример
```html

<div class="menu">
    <ul class="menu__list">
        <li class="menu__item menu__item--active">Главная</li>
        <li class="menu__item">О нас</li>
        <li class="menu__item">Контакты</li>
    </ul>
</div>

<button class="button button--primary">Отправить</button>
```

### Принципы БЭМ

| Именование |Изоляция|Переиспользование|Упрощение|
|-|-|-|-|
| Имена блоков, элементов и модификаторов должны быть описательными и четкими. Используйте двойное подчеркивание (__) для разделения блока и элемента, и двойное тире (--) для разделения блока/элемента и модификатора. |Блоки должны быть независимыми и не зависеть от других блоков. Это позволяет переиспользовать блоки в разных частях приложения.|Блоки и элементы должны быть спроектированы так, чтобы их можно было легко переиспользовать в разных контекстах.|Старайтесь избегать сложных зависимостей между блоками и элементами. Каждый блок должен иметь четкую ответственность.|

## Подключение скрипта в HTML:

```html
<!DOCTYPE html>
<html>
<head>
    <script src="script.js"></script>
</head>
<body>
</body>
</html>
```

В этом примере скрипт "script.js" будет подключен в секции <head> документа HTML.

### Внешний скрипт:

```js
alert("Hello, world!");
```

В этом примере скрипт "script.js" содержит одну команду - выводит предупреждение с текстом "Hello, world!".

### Встроенный скрипт:

```html

<script>
    alert("Hello, world!");
</script>
```

В этом примере скрипт находится непосредственно внутри тега `<script>`.

## async, defer

**async и defer** - это атрибуты, которые можно добавлять к элементам `<script>` в HTML. Они позволяют управлять способом
  загрузки и выполнения внешних скриптов.

| **async** | **defer** |
|-|-|
|Указывает браузеру загружать скрипт асинхронно. Это означает, что браузер будет продолжать обработку HTML-документа, не останавливаясь на загрузке и выполнении скрипта. Как только скрипт загружен, он будет выполнен в том порядке, в котором был указан (если не указан атрибут `defer`), и без ожидания других ресурсов страницы. Если на странице несколько скриптов с атрибутом `async`, выполнение будет происходить в порядке загрузки. | Указывает браузеру загружать скрипт отложено. Это означает, что браузер будет продолжать обработку HTML-документа, как и с атрибутом `async`, но выполнение скрипта будет отложено до тех пор, пока вся страница не будет полностью загружена. В случае наличия нескольких скриптов с атрибутом `defer`, выполнение будет происходить в том порядке, в котором они были указаны в HTML-документе. |

  Использование `async` и `defer` позволяет улучшить производительность загрузки страницы, так как скрипты могут загружаться
  параллельно с другими ресурсами и не задерживают рендеринг страницы. Однако, необязательно каждый скрипт помечать
  асинхронным или отложенным - в зависимости от конкретных требований страницы и его взаимодействия с другими элементами
  можно выбирать самостоятельно.

## Центрирование по горизонтали:

- С помощью свойства `text-align: center` для элементов с дисплеем `block`.
- Использование свойства `margin: 0 auto;` для блочных элементов с заданной шириной.
- Использование свойства `flex` и его свойства `justify-content: center;` для контейнера с дисплеем `flex`.

## Центрирование по вертикали:

- Использование свойств `display: flex;` и `align-items: center;` для контейнера.
- Позиционирование объекта абсолютно с помощью свойства `top` и `transform: translateY(-50%);`.
- Использование свойства `line-height` с фиксированным значением и задание высоты блока.

## Центрирование обоими способами:

- Использование свойств `flexbox` и `grid` для создания гибкой и адаптивной верстки.
- Использование свойства `position: absolute;` и комбинации свойств `top`, `left`, `right`, `bottom`, `transform` со значениями 50%.
- Использование псевдоэлемента `::before` или `::after` и комбинации свойств `position`, `top`, `left`, `right`, `bottom` со значениями
50%.

# JavaScript

***

## Основные нововведения в es6

- `let`
- деструктуризация (сразу достаю свойства через `{}`)
- стрелочные функции
- Операторы расширения (Spread и Rest)
  Spread: Позволяет развернуть массив или объект.
  Rest: Позволяет собирать оставшиеся аргументы в массив.
- Promis

## Виды тестирования (необязательно)

- Юнит - тестирование 1 компонента
- Интеграционное - тестирование группы компонентов
- Системное - тестирование всего приложения

## Отличия var, let, const

- `var` - глобальная область видимости, можно вызвать до её определения (hoisting)
- `let` - область видимости блочная, то есть где она объявлена, там и доступна. Вызывать можно только после её
  определения, иначе будут ошибки. Можно переопределить
- `const` - нельзя переопределить

## Что такое hoisting?

Hoisting (поднятие) - значит, что объявление переменной или функции перемещается в начало кода

## Как создать объект в js?

- через синтаксис «конструктор объекта» (ключевое слово `new`)

```javascript
let user = new Object()
```

- через синтаксис «литерал объекта»

```javascript
let user = {} // свойство - пара «ключ:значение»
```

## Отличие между while и for

- for принимает в себя 3 параметра - начальное значение, условие, шаг
- while выполняется пока принимаемое значение `boolean` не станет `false`

## Способы для сравнения объектов

- `JSON.stringify` - конвертирует объекты в строку и сравнивает.
  Но если свойства объектов идут не в одном порядке, то сравнение вернет false
- с помощью библиотеки __lodash_, есть метод `_.isEqual(объект1, объект2)`

## Зачем нужен оператор typeof?

Оператор typeof позволяет определить тип параметра. Он возвращает строку содержащую тип (string, number, object)

Особенности:

- Для null оператор возвращает object
- Для функций оператор возвращает function

## Что такое чистая функция?

Это функция работающая только с теми аргументами, которые в нее передали, и не имеющая side эффектов (сторонних
эффектов). То есть делает, что-то одно

## Что такое замыкание (closures) ?

Замыкание - это функция в функции, то есть внутренняя функция имеет доступ к данным родительской функции.

## Разница между стрелочной и обычной функции.

- В стрелочной функции отсутствует специальный объект `arguments`, содержащий в себе объект со всеми аргументами
  функции.
- Значение `this` внутри обыкновенной функции динамически зависит от контекста вызова. Собственный `this` внутри
  стрелочной функции отсутствует (`undefined`). Но когда стр. ф-ия используется в замыкании, то её `this` будет
  указывать на `this` внешней функции.
- Обычная функция (не анонимная) может быть вызвана до своего определения
- Если в стрелочная функция пишется в одну строку, можно не указывать `return`
- Можно использовать синтаксис стрелочных функций внутри класса. При этом в качестве `this` будет выступать объект
  класса.

## Различие function declaration и function expression

- _function declaration_ - должно содержать ключевое слово function, вызвать можно как до так и после его определения
- _function expression_ - вызвать можно только после определения

## Минусы callback функции

- Функция должна быть выполнена после того, как другая функция завершила выполнение
- Легко потеряться во вложенности

## Разница между операторами `=`, `==` и `===`

- `=` оператор присвоения
- `==` является не строгим сравнением (приводит типы данных к 1 виду)
- `===` строгое сравнение данных (без приведения типов)

## Rest & Spread операторы

В чем разница между spread-оператором и rest-оператором?
Операторы spread и rest имеют одинаковый синтаксис (`...`). Разница состоит в том, что с помощью spread мы передаем или
распространяем данные массива на другие данные, а с помощью rest — получаем все параметры функции и помещаем их в
массив (или извлекаем часть параметров).

## Что такое деструктуризация объекта (Object Destructuring)?
**Деструктуризация** — относительно новый способ получения (извлечения) значений объекта или массива. Использование
деструктуризации позволяет сделать код чище и отнимает меньше времени. Синтаксис деструктуризации следующий: заключаем
свойства объекта, которые хотим получить, в фигурные скобки (`{ }`), а если речь идет о массиве — в квадратные
скобки (`[ ]`)

## Оператор "!!"

`!!` (двойное отрицание) приводит значение справа от него к логическому значению.

## Типы данных

8 типов данных (7 примитивов и 1 непримитив)

- string - строка
- number - число
- boolean - логическое значение true/false
- null - специальное значение, указывает на его отсутствие
- underfined - специальное значение, указывает на то, что значение не установлено
- symbol - уникальное значение, часто применяется для обращения к свойствам сложных объектов
- bigint - очень большое число
- object - комплексный объект, составной тип данных, туда же массивы и функции

## В чем разница null и undefined?

`null` указывает на отсутствие значения, а `undefined` на его неопределенность

## Как можно привести одни типы к другим?

Преобразовать можно к `string`, `number`, `boolean`

- явное преобразование

```javascript
const age = 2
String(age) // "2"
```

- неявное с помощью конкатенации значения со строкой
  (к строке приводиться только при сложении)
  В остальных случаях (-, /, *) приравнивается к числу

```javascript
const age = 30 + "2" // "302"
```

## Что такое NaN, как проверить является ли значение NaN?

`NaN` - not a number (не число), способ проверки через функцию

```javascript
isNaN(значение)
```

## Какое значение имеет this?

`This` - ключевое слово, которое указывает на текущий контекст выполнения кода, если использовать `this` внутри какого-либо
объекта, то `this` ссылается именно на этот объект

## Методы `bind`, `call`, `apply` - привязывают контекст к какой-либо функции

- в метод `call()` параметры функции передаются через запятую
- в метод `apply()` в массив
- отличие `bind()` от `call()` и `apply()`, в том что `bind()` не вызывает функцию, он создает новую функцию с новым
  контекстом.
  Параметры передаются через запятую, как и в `call()`.

## Методы вставки\удаления

- `pop()` - удаляет последний элемент массива
- `push()` - добавляет элемент в начало массива
- `shift()` - удаляет первый элемент массива
- `unshift()` - добавляет элемент в начало массива

## Какой из этих методов быстрее и почему?

`push`/`pop` быстрее потому что работают с элементами в конце массива, а `unshift`/`shift` с его началом и для этих
операций требуется переиндексация всего массива

## Что если использовать вместо `pop`/`shift`/`splice` - `_delete_`?

На месте удаленных элементов останется `undefined`

## Методы для работы со всеми элементами массива

- `map()` - применяет к каждому элементу массива какое-то действие. Возвращает новый измененный массив, не изменяя
  предыдущий
- `forEach()` - изменяет исходный массив
- `filter()` - фильтрует массив по какому-то условию. Возвращает новый массив
- `find()` - ищет элемент по условию. Выведет только первый найденный элемент, даже если условию удовлетворяют несколько
  элементов
- `findIndex()` - ищет индекс по условию. Возвращает индекс искомого элемента, либо возвращает `-1`, если условие не
  выполнено, то есть элемент не найден
- `indexOf()` - ищет элемент в массиве и возвращает его индекс
- `reduce()` - применяет функцию reducer к каждому элементу массива, возвращая одно результирующее значение. Принимает 4
  аргумента, один из них аккумулятор - это необязательный параметр, используемый в качестве первого аргумента при первом
  вызове функции callback. Например, можно посчитать сумму чисел в массиве
- `includes()` - проверяет, содержит ли массив определенный элемент. Возвращает true, если элемент найден в массиве,
  иначе возвращает `false`.

## Другие методы

- `splice()` - удаляет элемент из массива и добавляет на его место другой. Не возвращает новый массив
- `slice()` - обрезает массив

## Методы строк

- `toUpperCase()`, `toLowerCase()` (смена регистра)
- `indexOf()`, `includes()` (поиск символов в строке)
- `slice()`, `substring()` (обрезка строки)
- `replace()`, `replaceAll()` (замена символов в строке)
- `repeat()` (повторение строки несколько раз)
- `trim()` (удаление лишних пробелов)

## Что такое Object.freeze?

`Object.freeze()` замораживает объект: это значит, что он предотвращает добавление новых свойств к объекту, удаление
старых свойств из объекта и изменение существующих свойств или значения их атрибутов перечисляемости, настраиваемости и
записываемости. В сущности, объект становится эффективно неизменным. Метод возвращает замороженный объект.

## Что такое Object.seal?

`Object.seal()` запечатывает объект, предотвращая добавление новых свойств к объекту и делая все существующие свойства
не настраиваемыми. Значения представленных свойств всё ещё могут изменяться, поскольку они остаются записываемыми

## В чем разница между методами Object.freeze и Object.seal?

Разница заключается в том, что при использовании метода `Object.freeze()` мы не можем менять или редактировать свойства
объекта, а при использовании `Object.seal()` такая возможность имеется, но в обоих случаях нельзя удалять и добавлять новые поля

## ООП - объектно ориентированное программирование (парадигма - это способ мышления, способ восприятия чего-либо)

- **Абстракция** - выделение важного для решения задач
- **Инкапсуляция** - сокрытие сложной реализации под понятным интерфейсом
- **Наследование** - перенятие свойств и методов одного класса другим
- **Полиморфизм** - возможность метода работать с аргументом и его наследниками

## Классы

- Наследование классов, `super()`
- Статические свойства и методы
- Приватные и защищённые методы и свойства

## Event, event listener, handler

Объект Event описывает событие, произошедшее на странице. Одной из причин возникновения событий являются действия
пользователя, такие как клики мышкой MouseEvent или ввод с клавиатуры KeyboardEvent

- **Event listener** - прослушиватель событий
- **Handler** - обработчик событий

## Что такое распространение события (Event Propagation)?

Когда какое-либо событие происходит в элементе DOM, оно на самом деле происходит не только в нем. Событие
«распространяется» от объекта Window до вызвавшего его элемента (event.target). При этом событие последовательно
пронизывает (затрагивает) всех предков целевого элемента. Распространение события имеет три стадии или фазы:

- Фаза погружения (захвата, перехвата) — событие возникает в объекте Window и опускается до цели события через всех ее
  предков.
- Целевая фаза — это когда событие достигает целевого элемента.
- Фаза всплытия — событие поднимается от event.target, последовательно проходит через всех его предков и достигает
  объекта Window.

## Что такое всплытие события?

Когда событие происходит в элементе DOM, оно затрагивает не только этот элемент. Событие «всплывает» (подобно пузырьку
воздуха в воде), переходит от элемента, вызвавшего событие (event.target), к его родителю, затем поднимается еще выше, к
родителю родителя элемента, пока не достигает объекта Window.

## Что такое погружение события?

Когда событие происходит в элементе DOM, оно происходит не только в нем. В фазе погружения событие опускается от объекта
Window до цели события через всех его предков.

## В чем разница между методами `event.preventDefault()` и `event.stopPropagation()`?

- `event.preventDefault()` отключает поведение элемента по умолчанию. Если использовать этот метод в элементе form, то он
  предотвратит отправку формы (submit). Если использовать его в contextmenu, то контекстное меню будет отключено
- `event.stopPropagation()` отключает распространение события (его всплытие или погружение).

## Как узнать об использовании метода `event.preventDefault()`?

Для этого мы можем использовать свойство `event.defaulPrevented`, возвращающее логическое значение, служащее индикатором
применения к элементу метода `event.preventDefault`.

## Зачем нужна асинхронность и какую проблему она решает?

Асинхронность - это способ взаимодействия с данными, когда не знаешь, в какой точно момент появятся данные.

Если код работает синхронно, то пользователь не сможет взаимодействовать со страницей, пока не придет результат.

Асинхронный код позволяет избежать этого. Он убирает блокирующую операцию из основного потока, пока она где-то
продолжает выполняться, а обработчик может идти дальше

## Event loop

`Event loop` - это событийный цикл, бесконечный цикл в котором JS ожидает задачи, выполняет их и ждет новые.
У него есть свой порядок, выполнения:

- сначала выполняются все макрозадачи (callstack выполнение кода от первой строчки до последней)
- вызывает все, что есть в очереди микрозадач (microtask queue - promise (`than`/`catch`/`finally`))
- вызывает все, что есть в очереди вызовов (callback queue - `setTimeOut()`, `setInterval()`)

## Что такое Promise ?

Promise (обещание) - это объект в JavaScript, представляющий результат асинхронной операции. Promise может находиться в
одном из трех состояний:

- pending (ожидание) - начальное состояние, когда Promise ещё не выполнен и не отклонен.
- fulfilled (выполнено) - состояние, когда Promise успешно выполнен, и берёт на себя ответственность вернуть результат.
- rejected (отклонено) - состояние, когда Promise отклонен из-за ошибки, и берёт на себя ответственность вернуть причину
  этой ошибки.

Promise используется для упрощения работы с асинхронными операциями, такими как запросы к серверу или задержка
выполнения кода. Вместо использования старого стиля с функциями обратного вызова (callback), синхронный код теперь может
быть записан асинхронно с цепочкой промисов и вызовами `.then()` и `.catch()`.

Методы promise:

- `.then()`: Обрабатывает успешное выполнение асинхронной операции. Когда промис завершается успешно (в состоянии "
  fulfilled"), функция, переданная в `.then()`, вызывается с результатом промиса. В `.then()` можно цепочкой добавлять
  последовательные асинхронные операции для обработки.
- `.catch()`: Обрабатывает возникшие ошибки во время выполнения промиса. Если промис завершается с ошибкой (состояние "
  rejected"), функция, переданная в `.catch()`, вызывается с информацией об ошибке. Добавляется после `.then()` для
  обработки ошибок.
- `.finally()`: Выполняет заданную функцию вне зависимости от результата промиса — успешного или ошибочного. Обычно
  используется для выполнения определенных действий, которые должны произойти в любом случае, например, очистка ресурсов
  или скрытие индикатора загрузки.

## Методы промисов Promise.all(),

- `.allSettled()`: ,
- `.any()`: ,
- `.race()`: ,
- `.resolve()`: ,
- `.reject()`:

## Основные понятия async/await. Зачем нужны async/await?

С `then()`/`catch()`/`finally()` - вызовы растут вправо, это не удобно. А с `async`/`await` - все идет линейно, код
становить более читабельным

## Разница setTimeOut и setInterval

- `setTimeOut()` - позволяет вызвать функцию один раз через определенный интервал времени
- `setInterval()` - позволяет вызывать функцию регулярно, повторяя вызов через определенный интервал времени



# TypeScript

***

## Назовите плюсы и минусы TS?

Плюсы:

- строгая типизация
- интерфейсы
- ооп
- компилятор реализует подход fail fast (получаешь обр. связь в момент написания кода а не в момент тестирования)
- очень хорошая поддержка TS в редакторах кода (советы, ошибки, и кододополнение намного лучше чем в JS)

Минусы:

- нужно больше учить (выше порог входа)
- Существующий код сложно перенести на TS
- Код из библиотек бывает сложно читать из-за обилия дженериков и прочего

_**Прим:**_ Некоторые библиотеки и фреймворки (например Angular) работают только с TS

## Почему нерекомендуется использовать any?

Тогда TS превращается в JS, тк «убивается» типизация

## Для чего нужны дженерики?

Дженерики в TypeScript являются мощным инструментом для создания гибкого и безопасного кода. Они помогают разработчикам писать более универсальные и устойчивые приложения, улучшая читаемость и поддерживаемость кода.

- Дженерики позволяют избежать ошибок, связанных с неправильным использованием типов, за счет проверки типов на этапе компиляции. Это помогает выявлять ошибки до запуска программы.
- С помощью дженериков можно создавать обобщенные функции и классы, которые могут работать с различными типами данных. Это уменьшает дублирование кода и делает его более универсальным.
- Код с дженериками становится более понятным, так как явным образом указываются ожидаемые типы данных. Это облегчает понимание кода и его поддержку.
- Дженерики позволяют создавать более гибкие API, которые могут адаптироваться к различным типам данных, что делает код более модульным и переиспользуемым.
- Дженерики часто используются для создания обобщенных коллекций (например, массивов, списков, карт), что позволяет хранить элементы разных типов, обеспечивая при этом безопасность типов.

## разница между type и interface?

- `type` не может расширяться в отличие от `interface`
- `type` может быть объявлен только 1 раз. Если интерфейс объявляется 2 раза, то его свойства «сливаются»
- Тип не может быть реализован, только объявлен. Интерфейс нужно реализовывать

## Зачем нужен тип unknow?

`unknown` является безопасной (с точки зрения типов) версией типа `any`.
Когда свойство объявлено как `any`, у него становится поведение как у обычного JS поля. Если поле объявлено
как `unknown`, у него нельзя вызвать никакого метода или свойства без явной проверки `unknown` на конкретный тип (
через `typeof`)



# React

***

## Что такое React?

React — это библиотека JavaScript с открытым исходным кодом, созданная Facebook для разработки сложных интерактивных
пользовательских интерфейсов в веб- и мобильных приложениях. Основная цель React — создание компонентов
пользовательского интерфейса; их часто называют просто «V» (View) в архитектуре «MVC».

## Что такое JSX?

JSX является расширением синтаксиса JavaScript и поставляется с полной функциональностью JavaScript. JSX производит
«элементы» React. Вы можете встроить любое выражение JavaScript в JSX, заключив его в фигурные скобки. После компиляции
выражения JSX становятся обычными объектами JavaScript. Это означает, что вы можете использовать JSX внутри операторов
if и циклов for, назначать его переменным, принимать в качестве аргументов и возвращать из функций.

## Что такое контролируемые компоненты?

В контролируемом компоненте данные формы обрабатываются состоянием внутри компонента. Состояние внутри компонента служит
«единственным источником правды» для элементов ввода, которые отображаются компонентом. Нам не нужен элемент формы на
странице, чтобы компонент был контролируемым компонентом.

## Что такое некотролируемые компоненты?

Неконтролируемые компоненты действуют больше как традиционные элементы формы HTML. Данные для каждого элемента ввода
хранятся в DOM, а не в компоненте. Вместо того чтобы писать обработчик событий для всех ваших обновлений состояния, вы
используете ref для получения значений из DOM.

## Фазы жизненного цикла компонентов React

| Тип | Описание                                                                                                                                                                                                       |
|-----|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|**Монтирование**| компонент React готов для монтирования в DOM браузера. Этот этап охватывает методы жизненного цикла `componentDidMount`                                                                                        |
|**Обновление**| на этом этапе компонент обновляется двумя способами, отправляя свойства и обновляя состояние. Этот                       этап охватывает методы жизненного цикла `shouldComponentUpdate`, `componentDidUpdate` |
|**Размонтирование**| на этом последнем этапе компонент не нужен и отключается из DOM браузера, этот этап включает метод `componentWillUnmount`|

Дополнительно:

- componentWillMount- перед рендерингом, в основном для настройки компонента
- render- процесс рендеринга
- componentDidMount- уведомляет, про то, что компонент соединен с DOM
  деревом
- componentWillReceiveProps- уведомляет, про то, что приходят новые
  входящие свойства в компонент
- shouldComponentUpdate- возвращает true или false и служит для
  оптимизации. Решает, нужно ли делать ре-рендеринг
- componentWillUpdate- уведомляет, что компонент будет обновлен
- componentDidUpdate- уведомляет, что компонент был обновлен
- componentWillUnmount- используется для удаления слушателей и очистки
  компонента. Вызывается перед удалением компонента

## Что такое Props?

Props это короткое название Properties в React. Они только для чтения. Они всегда передаются вниз от родителя к ребёнку.
Дочерний компонент никогда не может передать prop обратно родителю. Это помогает поддерживать однонаправленный поток
данных и обычно используется для рендера динамически генерируемых данных.

## Что такое состояние React?

State - это объект, которые определяют рендеринг и поведение компонентов. Он мутабельный и создает динамические и
интерактивные компоненты. После изменения state происходит ре-рендер компонента

## Для чего нужны keys в React?

Ключи используются для идентификации уникальных виртуальных элементов DOM с соответствующими данными, управляющими
пользовательским интерфейсом. Они помогают React оптимизировать рендеринг, перерабатывая все существующие элементы в
DOM. Эти ключи должны быть уникальными числами или строками, используя которые React просто переупорядочить элементы, а
не перерисовывает их. Это повышает производительность приложения.

## Для чего в React используется Virtual Dom?

Самые затратные операции в JS - это работа с DOM-дерево, это такие функции как `document.querySelector()`
или `getElementById()`.

То есть каждый раз, когда мы берем JS и делаем доступ до DOM-дерево, то требуется некоторое количество времени для того,
чтобы найти и получить в JS.

Когда приложение интерактивное и много взаимодействий, оно может тормозить.

Virtual Dom - легковесный JS объект, который представляет копию реального DOM-дерева

Нужен он для оптимизации взаимодействия с DOM

## Хуки

Хуки - это функции, с помощью которых можно подцепиться к состоянию и методам жизненного цикла React из функциональных
компонентов

Преимущество хуков : Хуки позволяют повторно использовать логику состояния, писать код проще, эффективнее использовать функционал, упрощает
разработку за счет декларативности

| Тип | Описание                                                                                | Пример |
|-----|-----------------------------------------------------------------------------------------|--------|
|`useState()`| управление состояние функционального компонента React                                   |`const [state, setState] = useState() // state - переменная, которая хранит само состояние // setState - функция, которая меняет состояние // (initialState) - начальное значение состояния`|
|`useEffect()`| используя этот хук мы говорим React сделать что-то после рендера. React запомнит это и вызовет функцию после того, как внесет изменения в DOM| `useEffect(() => {}, []) // [] - зависимости, при изменении которых срабатывает рендер` |
|`useContext()`| получение контекста в дочерних элементах                                                ||
|`useHistory()`|                                                                                         ||
|`useLocation()`|                                                                                         ||

## Из сторонних библиотек

- `useTable()` из React.Table
- `useForm()`

## Для чего нужен ref?

`ref` - это атрибут в React, который помогает хранить ссылку на определенный элемент или компонент, который будет
возвращен функцией конфигурации рендеринга компонентов.

Нужен:

- для интеграции со сторонами библиотеки
- когда нужно работать с фокусом, выделить текст или работа с медиа
- Для запуска императивной анимации (Императивная анимация работает в браузере основным потоком.)

## Что такое Context?

Контекст позволяет передавать данные через дерево компонентов без необходимости передавать пропсы на промежуточных
уровнях.

## MVC

Архитектурный паттерн в котором приложение представляется в виде 3 слоёв:

- **_Model_** - слой данных. В него входят базы данных.
- **_View_** - слой представления. В него входит весь фронт-энд.
- **_Controller_** - слой управления данными. Он же бэк-энд

## Что такое компоненты высшего порядка (High Order Component)?

HOC это кастомный компонент, который оборачивает другой компонент. Может принять любой динамически предоставленный
дочерний компонент, но они не будут изменять или копировать любое поведение из своих компонентов. Можно сказать что HOC
это чистый компонент.

## Действия с HOC

- Переиспользование кода, логики
- Абстракция и манипуляция state
- Манипуляция с props

## Flux

Flux - это архитектурный паттерн, который обеспечивает однонаправленный поток данных. Он контролирует производные данные
и обеспечивает связь между несколькими компонентами с использованием центрального хранилища, которые имеет полномочия
для всех данных. Любое обновление данных должно происходить только здесь. Flux обеспечивает стабильность приложения и
уменьшает ошибки во время выполнения.

## Разница между Презентационным и Контейнер компонентом?

- Презентационный - “как вещи выглядят”. Нужен для создания интерфейса. Работает на входящих параметрах
- Контейнер - “как вещи работают”. Обладают состоянием, подключены к Flux или Redux

# Redux

***

## Что такое Redux?

Это предсказуемый контейнер состояний для приложений JavaScript, который используется для управления состоянием всего
приложения.

## Принципы Redux?

- Единый источник правды: Состояние всего приложения хранится в дереве объектов/состояний в одном хранилище. Единое
  дерево состояний облегчает отслеживание изменений и отладку или проверку приложения.
- State только для чтения: Единственный способ изменить state вызвать Action. Action - это просто объект JS описывающий
  изменение.
- Изменения сделаны чистыми функциями: Чтобы указать, как дерево состояний трансформируется действиями, вам нужны чистые
  функции.

## Принципы Redux?

- Единый источник правды: Состояние всего приложения хранится в дереве объектов/состояний в одном хранилище. Единое
  дерево состояний облегчает отслеживание изменений и отладку или проверку приложения.
- State только для чтения: Единственный способ изменить state вызвать Action. Action - это просто объект JS описывающий
  изменение.
- Изменения сделаны чистыми функциями: Чтобы указать, как дерево состояний трансформируется действиями, вам нужны чистые
  функции.

## Компоненты Redux

- `Action` - Объект, который описывает что происходит
- `Reducer` - Место, где определяется как state изменится
- `Store` - Состояние/Объект дерева всего приложения которое хранится в Store
- `View` - Отображает данные, предоставленные Store

## Как `Actions` определяются в Redux?

`Action` в React должны иметь свойство `type` которое показывает тип Action. Они должны быть определены как строковая
константа, можно добавить еще свойства. В Redux actions создаются при помощи функции которая возвращает типа и данные.

## Объясните роль Reducer?

Reducers это чистые функции которые описывают как состояние приложения изменяется в ответ на `Action`. Reducer работает
принимая прежнее состояние и действие, а затем возвращает новое состояние. Он определяет, какое обновление необходимо
выполнить, основываясь на типе действия, а затем возвращает новые значение. Возвращает предыдущее состояние если не
нужно выполнять никаких действий

## Каково назначение Store в Redux?

`Store` - это JavaScript объект, который содержит состояние приложения и предоставляет несколько вспомогательных методов
для доступа к состоянию, рассылает действия и регистрирует слушателей. Все дерево состояний/объектов приложения
сохраняется в одном хранилище.

В результате Redux очень просто и предсказуем. Мы можем передать промежуточное программное обеспечение в хранилище для
обработки данных, а также для ведения журнала различных действий, которые изменяют состояние хранилищ. Все действия
возвращают новое состояние через reducers.



# Git

***

## Назовите основные команды `git`?

| Тип |Описание|
|-----|-|
|git init| инициализация нового репозитория;|
|git clone| клонирование существующего репозитория на локальный компьютер;|
|git add| добавление файлов в индекс (staging area);|
|git commit|  создание коммита с изменениями из staging area;|
|git status|  просмотр состояния репозитория и файлов;|
|git branch|  работа с ветками, создание, переключение и удаление;|
|git checkout|  переключение между ветками или возврат к предыдущему коммиту;|
|git merge| объединение изменений из одной ветки в другую;|
|git pull| получение изменений с удалённого репозитория и их слияние с текущей веткой;|
|git push|  отправка изменений с локальной ветки на удалённый репозиторий;|
|git revert|  отмена одного или нескольких последних коммитов;|
|git log| просмотр истории коммитов.|

## Разница между `merge` и `rebase`?

`Merge` — это процесс объединения изменений из одной ветви с другой веткой. Это позволяет сохранить историю коммитов и
создать новый коммит, который объединяет изменения из обеих веток.

`Rebase` — это способ переписать историю ветки так, чтобы она выглядела как непрерывная последовательность коммитов.
Rebase переносит все изменения из одной ветки в другую ветку, создавая новые коммиты. При этом история коммитов
переписывается, что может привести к потере истории или конфликтам при слиянии с другими ветками.

В целом, merge сохраняет историю коммитов, а rebase её переписывает. Merge обычно используется для объединения работы
нескольких разработчиков, а rebase — для очистки истории коммитов перед отправкой кода на сервер.

## Почему рекомендуют использовать концепцию `git flow`?

`Git flow` — это набор рекомендаций и практик для работы с Git, который помогает организовать процесс разработки
программного обеспечения.

`Git flow` предлагает использовать несколько веток для разных этапов разработки.
Использование `git flow` позволяет разработчикам работать над разными задачами одновременно, не мешая друг другу, а также
упрощает процесс выпуска новых версий продукта.

## Как можно отменить commit?

Чтобы отменить commit в Git, можно использовать команду `git revert`. Она создаёт новый коммит, который отменяет изменения
предыдущего коммита.

Синтаксис команды:

```git revert <commit-hash>```

где `<commit-hash>` — это хеш коммита, который вы хотите отменить.

Обратите внимание, что после выполнения этой команды история коммитов будет изменена, и вы не сможете вернуться к
предыдущему состоянию проекта.

## `merge` + решение конфликтов

`Git merge` — это команда, которая объединяет изменения из одной ветви с другой ветвью. Она позволяет сохранить историю коммитов и создать новый коммит, который объединяет изменения из обеих веток.

Однако иногда при слиянии ветвей могут возникать конфликты. Это происходит, когда изменения в одной ветке затрагивают те же строки кода, что и изменения в другой ветке. В этом случае Git не может автоматически объединить изменения и требует вмешательства разработчика.

## `fetch` и разница с `pull`

- `Git fetch` загружает изменения из удаленного репозитория (например, коммиты, ветки) и обновляет локальные ссылки на эти изменения, но не сливает их с вашей текущей веткой. Это просто обновление информации о том, что есть в удаленном репозитории.

- `Git pull` является комбинацией двух команд: git fetch и git merge. Она сначала загружает изменения из удаленного репозитория (как fetch), а затем автоматически сливает эти изменения с вашей текущей веткой.

## `stash`

`Stash` — это команда, которая временно сохраняет изменения в вашем рабочем каталоге, чтобы вы могли переключиться на другую ветку или выполнить другую задачу. После того как вы закончите работу над другой веткой или задачей, вы можете применить сохранённые изменения обратно к текущей ветке.

## `rebase`

`Rebase` — это процесс перемещения серии коммитов из одной ветки в другую. Это позволяет вам переписать историю вашей ветки так, чтобы она выглядела более линейной и последовательной. Rebase может быть полезен, когда вы хотите объединить несколько веток или удалить ненужные коммиты.

## `squash`

Squash — это способ объединения нескольких коммитов в один. Это полезно, когда у вас есть серия небольших коммитов, которые можно объединить в один более значимый коммит. Squash также может помочь вам упростить историю вашей ветки.

## `reset`

`Reset` — это команда, которая позволяет вам вернуться к предыдущему состоянию вашего репозитория. Вы можете использовать reset для отмены изменений, сделанных в вашей рабочей копии, или для возврата к определённому коммиту.

## `revert commit`

`Revert commit` — это действие, которое отменяет изменения, внесённые определённым коммитом. Revert создаёт новый коммит, который отменяет все изменения предыдущего коммита.

## `cherry-pick`

`Cherry-pick` — это возможность взять отдельный коммит из одной ветви и применить его к другой ветви. Это может быть полезно, если вы хотите добавить определённый набор изменений в свою текущую ветку.

## `patch`

`Patch` — это файл, содержащий изменения кода. В Git патчи используются для обмена изменениями между разработчиками или для создания новых версий программного обеспечения.

## `Git submodules`

`Git submodules` — это функция Git, которая позволяет включать в проект другие проекты как подмодули. Подмодули имеют свою собственную историю и могут быть обновлены независимо от основного проекта.

