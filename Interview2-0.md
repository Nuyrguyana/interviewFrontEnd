# Общие вопросы

***

## Способы хранения данных в браузере

|Тип|Описание|Срок хранения|Объем|
|-|-|-|-|
|**Cookie**|Небольшие файлы данных, которые хранятся на стороне клиента и отправляются на сервер с каждым HTTP-запросом|Куки могут иметь заданный срок жизни. Если срок не установлен, они будут храниться до закрытия браузера (сессионные куки). Если установлен срок, куки будут храниться до истечения этого срока.|Обычно ограничены 4KB на куки.|
|**localStorage**|Хранилище, позволяющее сохранять данные в формате ключ-значение на стороне клиента.|Данные в localStorage сохраняются бесконечно, до тех пор, пока пользователь не удалит их вручную или не очистит кеш браузера.|Обычно ограничено 5-10MB (в зависимости т браузера).|
|**sessionStorage**|Похож на localStorage, но данные сохраняются только на время текущей сессии.|Данные исчезают, когда вкладка или браузер закрывается.|Обычно также ограничено 5-10MB.|
|**Indexed DB**|более сложный механизм хранения данных, который позволяет хранить большие объемы структурированных данных. Он поддерживает транзакции и может работать с объектами, что делает его подходящим для более сложных приложений.|Данные в IndexedDB хранятся бессрочно, пока пользователь не удалит их вручную или не очистит кэш браузера.|

## Процессы, которые происходят в браузере, когда изменяются элементы в веб-приложении

|Тип|Описание|Пример|
|-|-|-|
| **Reflow**   | Процесс пересчета расположения элементов на странице. Он происходит, когда изменяются размеры элементов на странице, например, при изменении размера окна браузера, изменении шрифта или добавлении новых элементов на страницу        | Когда пользователь изменяет размер окна браузера, браузер пересчитывает расположение всех элементов на странице, чтобы они соответствовали новым размерам окна.                |
| **Repaint**  | Процесс обновления отображения элементов на странице без изменения их расположения. Он происходит, когда изменяются свойства элементов, влияющие только на их внешний вид, например, цвет фона, границы или текст.                     | Когда пользователь наводит курсор мыши на кнопку, она может изменять цвет фона или стиль, но ее расположение остается прежним.                                                 |
| **Composite** | Процесс, когда браузер отображает изменения на странице после Reflow и Repaint. Он происходит после того, как браузер заканчивает обновление отображения элементов на странице, и объединяет их в единую картинку для показа на экране. | Когда пользователь кликает на кнопку, браузер отображает изменения, связанные с Reflow и Repaint, и затем объединяет их в одну единую картинку, которая отображается на экране. |

## Виды клиент-серверного взаимодействия

| Тип                                        | Описание                                                                                                                                                                                                                                       | Пример                                                                                                        |
|--------------------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|---------------------------------------------------------------------------------------------------------------|
| **HTTP (HyperText Transfer Protocol)**     | Стандартный протокол для передачи данных в интернете. Клиент отправляет запрос серверу, и сервер отвечает данными (например, веб-страницей).                                                                                                   | Загрузка веб-страницы через браузер.                                                                          |
| **Long Polling**                           | Клиент отправляет запрос серверу и ожидает ответа. Если сервер не имеет новых данных, он не отвечает сразу, а удерживает соединение открытым до тех пор, пока не появятся новые данные. После получения данных клиент отправляет новый запрос. | Чат-приложения, где клиент ждет новых сообщений от сервера.                                                   |
| **WebSocket**                              | Протокол, который устанавливает постоянное соединение между клиентом и сервером для двусторонней передачи данных в реальном времени. Это позволяет обмениваться сообщениями без необходимости повторных запросов.                              | Онлайн-игры или приложения для обмена сообщениями, где требуется мгновенный обмен данными.                    |
| **SSE (Server-Sent Events)**               | Технология, позволяющая серверу отправлять обновления клиенту через однонаправленное соединение. Клиент устанавливает соединение, и сервер может отправлять данные, когда они становятся доступными.                                           | Уведомления о новых сообщениях или обновлениях на веб-странице.                                               |
| **REST (Representational State Transfer)** | Архитектурный стиль, использующий стандартные HTTP-методы (GET, POST, PUT, DELETE) для взаимодействия с ресурсами на сервере. Каждый ресурс имеет свой уникальный URL.                                                                         | API для работы с данными, где клиент может запрашивать, добавлять или изменять информацию.                    |
| **GraphQL**                                | Язык запросов для API, который позволяет клиенту запрашивать только те данные, которые ему нужны, вместо получения фиксированного набора данных.                                                                                               | Клиент может запрашивать конкретные поля из сложной структуры данных, сокращая объем передаваемой информации. |
| **gRPC (Google Remote Procedure Call)**    | Протокол удаленного вызова процедур, который использует HTTP/2 для связи между клиентом и сервером. Поддерживает двустороннюю потоковую передачу данных и более эффективное сериализованное представление данных.                              | Микросервисные архитектуры, где сервисы общаются друг с другом.                                               |
## Методы HTTP
HTTP (HyperText Transfer Protocol) использует несколько стандартных методов для выполнения различных операций с ресурсами на сервере. Вот основные методы HTTP:

> Идемпотентный - это при повторном вызове запроса ответ будет тем же

|Тип|Описание| Безопасность                                   | Иденпотентность                        | Данные                                                      |
|-|-|------------------------------------------------|----------------------------------------|-------------------------------------------------------------|
|GET|Используется для запроса данных с сервера| Безопасный          | Идемпотентный                          | Передаются в URL (в виде параметров запроса).               |
|POST| Используется для отправки данных на сервер, например, для создания нового ресурса.| Не безопасный              | Не идемпотентный                       | Обычно передаются в теле запроса.                           |
|PUT|Используется для обновления существующего ресурса или создания нового, если его не существует.| Не безопасный| Идемпотентный                          | Передаются в теле запроса.                                  |
|DELETE| Используется для удаления ресурса на сервере.| Не безопасный| Идемпотентный (если ресурс уже удален) | Обычно передаются в URL (идентификатор удаляемого ресурса). |
|PATCH|Используется для частичного обновления ресурса.| Не безопасный              | Не обязательно, зависит от реализации. | Передаются в теле запроса.                                  |
|HEAD|Запрашивает метаданные ресурса, не возвращая сам ресурс.|Безопасный| Идемпотентный                          | Не передает данных в теле, только в заголовках.             |
|OPTIONS|Используется для получения информации о доступных методах для конкретного ресурса.|                                Безопасный| Идемпотентный                          | Не передает данных в теле, только в заголовках.                                                            |
|TRACE|Метод используется для диагностики и отладки. Он возвращает содержимое запроса, который был отправлен на сервер, позволяя клиенту увидеть, как запрос был обработан.|   Безопасный                                             |Идемпотентный|Передает данные в теле запроса, возвращая их в ответе.|
|CONNECT|Метод используется для установки туннеля к серверу, чаще всего через прокси-сервер. Он позволяет создать соединение, например, для использования SSL (HTTPS) через HTTP-прокси.|Не безопасный  | Не идемпотентный(каждый вызов может устанавливать новое соединение)                     |Не передает данных в теле запроса, используется для создания соединения.|

## HTTP статус-кодов:

- Информационные ответы (100 – 199)
- Успешные ответы (200 – 299)
- Сообщения о перенаправлении (300 – 399)
- Ошибки клиента (400 – 499)
- Ошибки сервера (500 – 599)

## Что такое CORS?

**CORS (Cross-Origin Resource Sharing)** — это механизм безопасности в вебе, который позволяет браузерам контролировать,
какие ресурсы могут загружаться с других доменов.

- Безопасность: CORS помогает предотвратить атаки, такие как межсайтовый скриптинг (XSS).
- Заголовки: Сервер использует заголовки, такие как Access-Control-Allow-Origin, чтобы указать, какие домены могут
  получать доступ к его ресурсам.
- Запросы: CORS применим только к запросам, сделанным с помощью JavaScript в браузере, и не влияет на обычные
  HTTP-запросы, сделанные с серверов.

## Критические этапы рендеринга

**Рендеринг веб-страницы** — это процесс, в ходе которого браузер преобразует HTML, CSS и JavaScript в визуальное
представление, которое пользователь видит на экране. Этот процесс можно разделить на несколько критических этапов:

- **Загрузка ресурсов**\
  Браузер отправляет HTTP-запросы на сервер для получения HTML-документа и других ресурсов (CSS, JavaScript, изображения
  и т. д.).
  Полученные ресурсы загружаются в браузер.
- **Парсинг HTML**\
  Браузер начинает парсить (анализировать) HTML-документ и строит дерево элементов (DOM — Document Object Model).
  Каждая HTML-тег становится узлом в дереве.
- **Парсинг CSS**\
  Одновременно с парсингом HTML браузер парсит CSS-файлы и встроенные стили, создавая дерево стилей (CSSOM — CSS Object
  Model).
  Это дерево содержит информацию о стилях, применяемых к элементам DOM.
- **Создание рендер-дерева**\
  Браузер объединяет DOM и CSSOM для создания рендер-дерева.
  Рендер-дерево содержит только те узлы, которые должны быть отображены на экране, и включает в себя информацию о стилях
  для каждого элемента.
- **Расчет геометрии (layout)**\
  На этом этапе браузер вычисляет размеры и положение каждого элемента на странице.
  Этот процесс называется layout или reflow.
- **Рисование (painting)**\
  Браузер начинает рисовать элементы на экране, начиная с фона и заканчивая текстом и изображениями.
  Этот процесс называется painting.
- **Составление слоев (compositing)**\
  В современных браузерах элементы могут быть разделены на слои для более эффективного рендеринга.
  Браузер объединяет слои и отображает окончательное изображение на экране.
- **Обработка JavaScript**\
  JavaScript может изменять DOM и CSSOM, что может привести к повторному рендерингу (repaint) или перерасчету (reflow).
  Браузер обрабатывает JavaScript, который может блокировать рендеринг, если он не выполнен асинхронно.

## GreenField и BrownField

- **GreenField** (зеленое поле) — это проект, который начинается с нуля, на "чистом" месте, где нет никаких предварительных разработок или существующих структур
- **BrownField** (коричневое поле) — это проект, который начинается на уже существующей базе, где есть предшествующие разработки или структуры

## Функциональные и нефункциональные требования

|Тип|Описание| Пример                                                                                                                                                                                                    |
|-|-|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|Функциональные требования|Функциональные требования описывают, что система должна делать. Они определяют функции, возможности и поведение системы.| 1. Пользователь должен иметь возможность зарегистрироваться на сайте. 2. Система должна обрабатывать платежи через кредитные карты. 3. Приложение должно предоставлять возможность поиска по базе данных. |
|Нефункциональные требования|Нефункциональные требования описывают, как система должна выполнять свои функции. Они касаются качественных характеристик системы, таких как производительность, безопасность, надежность и удобство использования.| 1. Система должна обрабатывать 1000 запросов в секунду. 2. Время отклика приложения не должно превышать 2 секунд. 3. Данные пользователей должны быть защищены с помощью шифрования.                      |

Основные отличия
- Содержание: Функциональные требования фокусируются на "что" система должна делать, в то время как нефункциональные требования фокусируются на "как" это должно быть сделано.
- Измеримость: Функциональные требования часто легче измерить и протестировать, тогда как нефункциональные требования могут требовать более сложных методов оценки и проверки.

## Для чего webpack и какие задачи он выполняет

Webpack - это сборщик модулей. Он анализирует модули приложения, создает граф зависимостей, затем собирает модули в
правильном порядке в один или более бандл (bundle), на который может ссылаться файл (`index.html`)

Если загрузить скрипт, зависящий от React, до загрузки самого React, приложение сломается. Webpack - решает эти задачи.
Не нужно беспокоиться о последовательности подключения всех скриптов

# HTML

>HTML (HyperText Markup Language) — это язык разметки, который используется для создания веб-страниц. Простыми словами, HTML — это основа любого сайта, которая определяет структуру и содержание страницы.

***

## Отличие блочных и строчных элементов

|Тип|описание|примеры|
|-|-|-|
|**Строчные**|- ширина зависит от содержимого <br>- Нельзя задать ширину и высоту<br>- Не переносится на новую строку<br>- Может содержать в себе только контент и другие строчные элементы|`<span>`<br> `<a/>`<br> `<img/>`<br> `<button>`<br> `<input>`|
|**Блочные**|- по умолчанию занимают всю ширину страницы <br>- начинаются с новой строки<br>- могут содержать в себе другие блочные или строчные элементы|`<div>`<br> `<p/>`<br> `<ul>`<br> `<ol>`<br> `<h1>`…`<h6>`|

## Структура HTML

```html

<doctype html> - тип документа
    <html> - вся страница
    <head> - основная инфа (заголовок, кодировка, мета инфа, подключение стилей)
    </head>
    <body> - содержание страницы
    </body>
    </html>
```

## Мета теги

Мета-теги в HTML используются для предоставления информации о веб-странице для поисковых систем и браузеров. Они помещаются в раздел <head> вашего HTML-документа. Вот некоторые из наиболее распространенных мета-тегов:

- `<meta charset="UTF-8">` - Определяет кодировку символов для веб-страницы. Рекомендуется использовать кодировку UTF-8
  для поддержки всех символов и языков.
- `<meta name="viewport" content="width=device-width, initial-scale=1.0">` - Управляет сжатием и масштабированием
  веб-страницы на мобильных устройствах.
- `<meta name="description" content="Описание вашей страницы">` - Предоставляет краткое описание содержимого вашей
  страницы. Это описание часто отображается в результатах поиска.
- `<meta name="keywords" content="ключевое слово 1, ключевое слово 2, ...">` - Указывает ключевые слова или фразы,
  связанные с вашей страницей. Этот тег менее важен для поисковых систем сегодня, но все же может быть полезен.
- `<meta name="author" content="Имя автора">` - Указывает имя автора веб-страницы.
- `<meta http-equiv="refresh" content="5; URL=http://example.com">` - Позволяет автоматически перенаправить пользователя
  на другую страницу через указанное количество секунд.

Они могут быть полезны для оптимизации сайта, для поисковых систем и предоставления полезной информации о веб-странице.

## Виды подключения скриптов на страницу

- Встраивание скриптов в HTML:

Внутренние скрипты: Скрипты могут быть написаны непосредственно в HTML-документе внутри тега `<script>`. Например:
```html
<script>
  console.log('Hello, World!');
</script>
```
- Подключение внешних скриптов:

Внешние файлы: Скрипты можно подключать из внешних файлов, указав путь к файлу в атрибуте src тега `<script>`. Например:
```html
<script src="script.js"></script>
```
- Асинхронная загрузка:

`async`: Этот атрибут позволяет загружать скрипт асинхронно, что означает, что скрипт будет загружен параллельно с загрузкой страницы и выполнится, как только будет загружен. Это может улучшить производительность страницы.
```html
<script src="script.js" async></script>
```
- Отложенная загрузка:

`defer`: Этот атрибут также позволяет загружать скрипт асинхронно, но гарантирует, что скрипт будет выполнен только после полной загрузки HTML-документа. Это полезно, если скрипт зависит от `DOM`.
```html
<script src="script.js" defer></script>
```
- Событийная загрузка:

`DOMContentLoaded`: Можно использовать событие `DOMContentLoaded`, чтобы выполнить скрипт после полной загрузки `DOM`. Например:
```html
<script>
  document.addEventListener('DOMContentLoaded', function() {
  });
</script>
```
- Модули ES6:

С помощью атрибута `type="module"` можно подключать скрипты как модули, что позволяет использовать функциональность модульной системы JavaScript.
```html
<script type="module" src="module.js"></script>
```

## Семантическая верстка

**Семантическая верстка** - это подход к разметке, которая опирается на смысловое предназначение и логическую структуру документа, чтобы сделать приложение доступным. Например, с помощью скринридера, человек с особенностями может ориентироваться по
сайту  
Чтобы поисковики выдавали результат выше

Примеры тегов:

- `<header>` - шапка сайта
- `<main>` - основное содержимое
- `<footer>` - подвал сайта
- `<nav>` - навигация по сайту (ссылки)
- `<section>` - для разделения на секции. Обязательный дочерний элемент - заголовок
- `<article>` - для статей, записей, новостей. Обязательный дочерний элемент - заголовок
- `<asade>` - боковая панель сайта

## Отличие тега `<img/>` от тега `<picture/>`? 

1.`<img>`

- Основное назначение: Тег `<img>` используется для вставки изображения на страницу. Он является простым и прямым способом отображения изображений.

- Семантика: `<img>` является одиночным элементом, который не содержит других элементов. Он имеет атрибуты, такие как `src`, `alt`, `width`, `height`, и другие, которые определяют источник изображения и его характеристики. Атрибут `alt` важен для доступности, так как он предоставляет текстовое описание изображения для пользователей с ограниченными возможностями.

- Простота использования: `<img>` используется, когда нужно просто отобразить одно изображение без учета различных условий отображения (например, размера экрана или разрешения).

2. `<picture>`
- Основное назначение: Тег `<picture>` используется для более сложных сценариев отображения изображений, позволяя разработчикам предоставлять разные версии изображения в зависимости от условий, таких как размер экрана или разрешение устройства.

- Семантика: `<picture>` является контейнером, который может содержать один или несколько элементов `<source>` и один элемент `<img>`. Каждый элемент `<source>` может иметь атрибуты `media` и `srcset`, которые определяют, при каких условиях должно использоваться соответствующее изображение. Это позволяет более точно управлять тем, какое изображение будет загружено в зависимости от устройства пользователя.

- Адаптивность: Использование тега `<picture>` позволяет создавать адаптивные изображения, которые подстраиваются под различные размеры экранов и разрешения, что улучшает производительность и пользовательский опыт.


## Медиа-Запросы

Медиа-запросы в HTML и CSS используются для определения стилей и разметки, которые должны применяться в зависимости от
характеристик устройства или экрана пользователя. Это позволяет создавать адаптивные веб-сайты, которые выглядят и
функционируют оптимально на различных устройствах.

Медиа-запросы в HTML обычно применяются с помощью атрибута media в теге `<link>` или `<style>`. Например:

HTML

```html

<link rel="stylesheet" media="screen and (max-width: 768px)" href="small.css">
```

- В данном примере стиль, определенный в файле "small.css", будет применяться только на экранах с шириной до 768
  пикселей.

Также медиа-запросы могут быть использованы внутри CSS для определения различных стилей для разных устройств. Например:

CSS

```css
@media screen and (max-width: 768px) {
    body {
        background-color: lightblue;
    }
}
```

Этот код задает светло-голубой фон для тела страницы, только если ширина экрана меньше или равна 768 пикселям.

## Какие браузеры поддерживают HTML5?

Практически все браузеры, но можно проверить совместимость версий языка с браузера на
сайте [caniuse.com](https://caniuse.com/)

## Почему важно указывать атрибут `alt` для `<img/>`?

Атрибут `alt` устанавливает альтернативный текст для изображений. Например, у браузера отключена загрузка изображений,
вместо него будет текстовая информация.

## Для чего нужны Data атрибуты?

**Data** атрибуты позволяют хранить дополнительную информацию в стандартных элементах html. JavaScript может легко получать доступ к data-атрибутам через DOM. Это позволяет динамически изменять поведение элементов на странице на основе данных, хранящихся в этих атрибутах.

## Web Components

Web Components — это набор технологий, которые позволяют создавать переиспользуемые, инкапсулированные элементы пользовательского интерфейса для веб-приложений. Они позволяют разработчикам создавать собственные HTML-теги с уникальным поведением и стилями. Основные технологии, входящие в состав Web Components, включают:

- Custom Elements: Позволяют создавать новые HTML-теги с определенной функциональностью. Например, вы можете создать тег `<my-button>`, который будет вести себя по-особенному.

- Shadow DOM: Обеспечивает изоляцию стилей и скриптов для ваших компонентов. Это значит, что стили внутри компонента не будут конфликтовать с другими стилями на странице.

- HTML Templates: Позволяют определять фрагменты HTML, которые можно повторно использовать. Шаблоны не отображаются на странице, пока их не активируют с помощью JavaScript.

Преимущества Web Components:
- Переиспользуемость: Компоненты можно использовать в разных проектах без изменений.
- Инкапсуляция: Логика и стили компонента изолированы от остальной части страницы, что предотвращает конфликты.
- Совместимость: Web Components работают во всех современных браузерах и могут быть использованы вместе с другими библиотеками и фреймворками.

## Что такое Canvas?

`Canvas` - это HTML элемент, который представляет собой область, на которой можно рисовать графику с помощью JavaScript.
Он предоставляет API для создания и управления изображениями, анимацией и интерактивными элементами, такими как линии,
формы, текст и т. д. Canvas позволяет разработчикам создавать динамический и интерактивный контент с помощью
программного кода.

## CSS Modules

CSS Modules — это метод организации CSS-кода, который помогает избежать конфликтов имен и делает стили более управляемыми. Вот основные моменты, объясняющие, что такое CSS Modules простыми словами:

- Локальная область видимости: В отличие от обычного CSS, где все классы глобальны, CSS Modules применяют стили только к конкретному компоненту. Это означает, что классы, определенные в одном файле, не будут влиять на стили в других файлах.
- Автоматическое именование: Когда вы используете CSS Modules, классы автоматически получают уникальные имена. Например, класс .button может стать .Button__button__1a2b3, что предотвращает конфликты с другими классами с тем же именем.
- Импорт и использование: Вы импортируете CSS-файл в ваш JavaScript-код и используете стили как объект. Например:

```jsx
import styles from './Button.module.css';

function Button() {
return <button className={styles.button}>Нажми меня</button>;
}
```
- Удобство: CSS Modules делают код более структурированным и читаемым, особенно в больших проектах, так как стили привязаны к компонентам, а не к глобальной области.

Преимущества CSS Modules:
- Избежание конфликтов: Локальные классы предотвращают проблемы с переопределением стилей.
- Упрощение поддержки: Легче управлять стилями, так как они связаны с конкретными компонентами.
- Чистый код: Код становится более организованным и понятным.

# CSS

> CSS расшифровывается как Cascading Style Sheets, что в переводе означает каскадные таблицы стилей. CSS — это язык стилевого оформления, который используется для описания внешнего вида и форматирования HTML-документов. Он позволяет отделить содержание (HTML) от визуального представления, что делает разработку веб-страниц более структурированной и удобной.
> 
> Каскадность — это ключевая концепция в CSS, которая определяет, как стили применяются к элементам на странице. Каскадность подразумевает, что стили могут наследоваться от родительских элементов к дочерним, и что при наличии конфликтующих стилей (например, когда несколько правил применяются к одному элементу) применяется правило приоритета.
***

## Единицы измерения

- `px` - абсолютные
- `em` - относительно размера шрифта родителя
- `rem` - относительно размера шрифта HTML
- `vm` - относительно размеров экрана
- `vh` - относительно размеров экрана

## Что такое псевдоклассы?

**Псевдокласс в CSS** — это ключевое слово, добавленное к селектору, которое определяет его особое состояние. Нужен для
интерактива элементов.

## Какие есть псевдоклассы?

- `:hover` - наведение курсором на элемент
- `:focus` - состояние фокуса. Выбранный элемент выделяется
- `:active` - выделение элемента при нажатии
- `:visited` - меняет цвет, если на элемент уже нажимали
- `:disabled` - если задан одноименный атрибут кнопке, то применится этот псевдокласс, после `:hover` делает кнопку
  неактивной

## Для чего нужны псевдоэлементы?

Для декорации

## Какие есть псевдоэлементы?

- `::after` - вставляет содержимое _**после**_ элемента
- `::before` - вставляет содержимое _**до**_ элемента
  _**Прим.:**_ Обязательное свойство для этих псевдоэлементов - `content: ""`
- `::first-letter` - первая буква с индивидуальными стилями
- `::first-line` - первая строка с индивидуальными стилями

## Вес селекторов от меньшего к большему

1. Псевдоэлементы // 1
2. Тег // 1
3. Псевдоклассы // 10
4. class // 10
5. id // 10
6. `!important`
7. атрибут HTML _**style**_ // 1000
8. атрибут HTML _**style `!important`**_

## Position

- `static` - по умолчанию
- `relative` - устанавливается относительно его изначального положения.
- `absolute` - позиционируется относительно странице, как бы выдергиваясь из контекста. Если родительскому блоку
  установить `position: relative`, то блок с `position: absolute` будет перемещен относительно родительского блока
- `fixed` - так же как и `position: absolute` вырывает блок из потока и фиксируется относительно окна браузера
- `sticky` - гибрид `position: static` и `position: fixed`, блок статичен, но как только скрол достигает границу блока,
  он фиксируется и прибивается как в случае `position: fixed`

## Display

Свойство, которое определяет, как элемент должен быть показан в документе

- `block` - элемент показывается как блочный. Из строчного можно сделать блочный и к нему применятся свойства как у
  блочного
- `inline` - элемент показывается как строчный
- `inline-block` - ведет себя как строчный элемент, но указывая св-ва блочного элемента, они применяются к нему (ширина,
  высота, отступы)
- `none` - удаляет блок, как будто бы его и не было
- `flex` - элементы отрисовываются в ряд относительно их контейнера, к которому применен `flex`. Сам контейнер остается
  блочным.
- `inline-flex` - подобен `inline-block`
- `grid`

## Display flex

К `flex` можно применить сво-во `justify-content`, которое определяет выравнивание вдоль основной оси. По
умолчанию `justify-content:flex`. Также есть значения:

- `flex-start` - определяет адаптивность всех элементов под самый высокий элемент. Занимает столько сколько нужно и
  прижимает их к верху контейнера
- `flex-end` - то же что и `flex-start`, но прижимает к низу контейнера
- `center` - становится по центру относительно самого высокого эл-та
- `flex-wrap` - если эл-там не хватает места в контейнере, они смещаются ниже. Адаптация `nowrap` отменяет
  адаптацию. `wrap-reverse` так же как и `wrap`, но перемещение будет задом на перед.
- `space-between` -
- `space-around` - Пространство с каждой стороны эл-та (лево\право)
- `align-items` - определяет поведение вдоль поперечной оси (по оси столбца). По умолчанию `align-items:stretch`.
  Элементы подстраиваются под высоту самого высокого эл-та.
- `align-content` - тип выравнивания строк внутри flex-контейнера по поперечной оси при наличии свободного пространства.
- `order` (цифра) - определяет порядок элементов. От меньшего к большему.
- `flex-grow` (цифра) - задаёт коэффициент роста для заданного числа

## Display grid

- `inline-grid` - формирует сетку как строчный элемент
- `grid-template-columns` - определяет размеры grid-колонок. Можно указывать в `px` (точный размер), в `px` и `fr` (
  остаточная ширина), `repeat` (число колонок, px(размер, ширина))
- `grid-template-rows` - определяет размеры grid-строк. Можно указывать в `px` (точный размер), в `px` и `fr` (
  остаточная высота), `repeat` (число строк, px(размер, высота))
- `gap` - задаёт отступы между столбцами и строками
- `align-items` - выравнивает вдоль оси столбца
- `align-content` - выравнивает сетку вдоль оси колонки
- `justify-items` - выравнивает содержимое вдоль оси строки
- `justify-content` - выравнивает сетку вдоль оси строки
- `grid-auto-flow` - `row` заполняет строки по очереди, `column` заполняет столбцы по очереди
- `justify-self` - выравнивает содержимое эл-та вдоль оси строки
- `align-self` - выравнивает содержимое эл-та вдоль оси столбца

## Разница между `flexbox` и `grid`

- `flexbox` позиционирует эл-ты в одном направлении, строке или колонке
- `grid` позиционирует эл-ты в двумерной системе, то есть одновременно и в строке и в колонке.

## display:table

- `display:table`
- `display:table-row`
- `display:table-header-group`
- `display:table-row-group`
- `display:table-footer-group`
- `display:table-column`
- `display:table-column-group`
- `display:table-ceil`
- `display:table-caption`

## Разница display: none и visibility: hidden

- `display: none` полностью скрывает элемент со страницы и всё выглядит так, как если бы его вообще не было
- `visibility: hidden` просто делает элемент невидимым, но сохраняет занимаемое им место

## z-index

`z-index` меняет положение по оси Z. Чем больше индекс, тем выше будет находиться эл-т

## Для чего нужен `box-sizing:border-box`?

На размер блока ничего не будет влиять. Border, padding и пр. будут идти внутрь, а контент будет уменьшаться.

## Препроцессоры CSS и постпроцессоры CSS

Препроцессоры CSS и постпроцессоры CSS - это инструменты, используемые для упрощения и оптимизации разработки CSS.
- Препроцессоры CSS используются для написания более удобного и модульного кода CSS
- Постпроцессоры CSS используются для оптимизации и улучшения производительности обычного CSS.

|Тип|Инструмент|Функциональность|Трансформация|Дополнительные инструмента|
|-|-|-|-|-|
| **Препроцессоры CSS**  | Препроцессоры CSS (например, Sass, Less, Stylus) представляют собой расширения стандартного CSS и обычно имеют собственный синтаксис и возможности. | Они предлагают дополнительные функции, такие как переменные, миксины (шаблоны стилей), операторы, вложенность правил и многое другое. Это позволяет разработчикам писать более модульный и эффективный CSS. | Препроцессоры преобразуют код на своем синтаксисе в обычный CSS до его использования в веб-приложении или сайте.| Они часто включают в себя командную строку или графический интерфейс для компиляции кода и проверки ошибок.|
| **Постпроцессоры CSS** | Постпроцессоры CSS (например, Autoprefixer, CSSNano, PostCSS) работают непосредственно с обычным CSS, который написан разработчиками. | Они предлагают дополнительные возможности для оптимизации CSS, такие как автоматическое добавление вендорных префиксов, удаление неиспользуемого кода, сжатие и объединение файлов CSS и т.д. | Постпроцессоры преобразуют обычный CSS для оптимизации и улучшения его производительности.| Они предоставляют возможность использования различных плагинов и расширений для настройки процесса обработки CSS.|

## Какую проблему решают препроцессоры и зачем они нужны?

- С помощью препроцессора можно указать переменную в которой будет храниться св-во, и далее использовать эту переменную.
  И в случае когда свойство поменялось, сделать это можно только в переменной. В остальные места подтянется.
- Можно использовать _**import**_, то есть в один файл подтянуть все остальные файлы CSS, и на выходе получить только
  один файл который подгружается `@include`
- В обычном CSS нужно указываться родительский блок и его вложенность. При использовании препроцессора можно этого
  избежать. Т.е. написать один раз род. блок и вкладывать в него элементы.
- _**Миксины**_ (Mixin) - примесь стилей позволяет сделать блок силей, которые могут быть неоднократно использованы.

`@mixin <имя миксина> {параметры}
p{@include имя;}`

```scss
@mixin mixinName($color, $width) {
  border: {
    color: $color;
    width: $width;
  };
}

p {
  @include mixinName(red, 2px);
}
```
## Свойства в SCSS
SCSS (Sassy CSS) — это расширение CSS, которое добавляет множество возможностей, таких как переменные, вложенность, миксины, функции и другие. Вот основные свойства и возможности SCSS:

1. Переменные
   Переменные позволяют хранить значения и использовать их в различных местах вашего кода.
```scss
$primary-color: #3498db;

.button {
background-color: $primary-color;
}
```
2. Вложенность
   SCSS поддерживает вложенность, что позволяет писать стили более структурированно и удобно.
```scss
.nav {
ul {
list-style: none;
}

li {
display: inline-block;
}
}
```
3. Миксины
   Миксины позволяют создавать группы CSS-правил, которые можно переиспользовать.
```scss
@mixin border-radius($radius) {
-webkit-border-radius: $radius;
-moz-border-radius: $radius;
border-radius: $radius;
}

.box {
@include border-radius(10px);
}
```
4. Наследование
   SCSS поддерживает наследование с помощью директивы @extend, что позволяет избежать дублирования кода.
```scss
.error {
color: red;
}

.alert {
@extend .error;
font-weight: bold;
}
```
5. Функции
   SCSS позволяет создавать функции для выполнения операций и вычислений.
```scss
@function calculate-rem($pixels) {
@return $pixels / 16 * 1rem;
}

body {
font-size: calculate-rem(18px);
}
```
6. Массивы и карты
   SCSS поддерживает массивы и карты (объекты), что позволяет хранить и управлять связанными данными.
```scss
$colors: (primary: #3498db, secondary: #2ecc71);

.button {
background-color: map-get($colors, primary);
}
```
7. Медиазапросы
   Медиазапросы можно писать внутри вложенных блоков, что делает их более организованными.
```scss
.container {
width: 100%;

@media (min-width: 768px) {
width: 50%;
}
}
```
8. Импорт
   SCSS позволяет разбивать код на несколько файлов и импортировать их.
```scss
@import 'variables';
@import 'mixins';
@import 'components/button';
```
9. Циклы
   SCSS поддерживает циклы, что позволяет генерировать стили динамически.
```scss
@for $i from 1 through 3 {
.column-#{$i} {
width: 100% / 3 * $i;
}
}
```
10. Условия
    SCSS поддерживает условные конструкции, что позволяет изменять стили в зависимости от условий.
```scss
$theme: dark;

.button {
@if $theme == dark {
background-color: black;
} @else {
background-color: white;
}
}
```
## БЭМ (Блок, Элемент, Модификатор)

Методология разработки веб-интерфейсов, которая предлагает способ организации и структурирования кода. Она помогает
сделать код более понятным, модульным и легко расширяемым.

В БЭМ вся верстка разбивается на независимые блоки, которые могут быть повторно использованы. Каждый блок состоит из
элементов, которые являются частью блока и не могут существовать вне него. Также у блока могут быть модификаторы,
которые меняют его внешний вид или поведение.

### Основные понятия

|Блок|Элемент|Модификатор|
|-|-|-|
| Независимый компонент интерфейса, который может быть использован в разных местах. Например, это может быть навигационное меню, кнопка или форма. Пример: menu, button, form. | Часть блока, которая не может существовать отдельно от него. Элементы описывают составные части блока. Пример: menu__item, button__icon, form__input. | Используется для обозначения различных состояний или внешнего вида блока или элемента. Модификаторы позволяют изменять внешний вид или поведение блоков и элементов. Пример: button--primary, menu__item--active, form__input--error. |

### Пример
```html

<div class="menu">
    <ul class="menu__list">
        <li class="menu__item menu__item--active">Главная</li>
        <li class="menu__item">О нас</li>
        <li class="menu__item">Контакты</li>
    </ul>
</div>

<button class="button button--primary">Отправить</button>
```

### Принципы БЭМ

| Именование |Изоляция|Переиспользование|Упрощение|
|-|-|-|-|
| Имена блоков, элементов и модификаторов должны быть описательными и четкими. Используйте двойное подчеркивание (__) для разделения блока и элемента, и двойное тире (--) для разделения блока/элемента и модификатора. |Блоки должны быть независимыми и не зависеть от других блоков. Это позволяет переиспользовать блоки в разных частях приложения.|Блоки и элементы должны быть спроектированы так, чтобы их можно было легко переиспользовать в разных контекстах.|Старайтесь избегать сложных зависимостей между блоками и элементами. Каждый блок должен иметь четкую ответственность.|

## Подключение скрипта в HTML:

```html
<!DOCTYPE html>
<html>
<head>
    <script src="script.js"></script>
</head>
<body>
</body>
</html>
```

В этом примере скрипт "script.js" будет подключен в секции <head> документа HTML.

### Внешний скрипт:

```js
alert("Hello, world!");
```

В этом примере скрипт "script.js" содержит одну команду - выводит предупреждение с текстом "Hello, world!".

### Встроенный скрипт:

```html

<script>
    alert("Hello, world!");
</script>
```

В этом примере скрипт находится непосредственно внутри тега `<script>`.

## async, defer

**async и defer** - это атрибуты, которые можно добавлять к элементам `<script>` в HTML. Они позволяют управлять способом
загрузки и выполнения внешних скриптов.

| **async** | **defer** |
|-|-|
|Указывает браузеру загружать скрипт асинхронно. Это означает, что браузер будет продолжать обработку HTML-документа, не останавливаясь на загрузке и выполнении скрипта. Как только скрипт загружен, он будет выполнен в том порядке, в котором был указан (если не указан атрибут `defer`), и без ожидания других ресурсов страницы. Если на странице несколько скриптов с атрибутом `async`, выполнение будет происходить в порядке загрузки. | Указывает браузеру загружать скрипт отложено. Это означает, что браузер будет продолжать обработку HTML-документа, как и с атрибутом `async`, но выполнение скрипта будет отложено до тех пор, пока вся страница не будет полностью загружена. В случае наличия нескольких скриптов с атрибутом `defer`, выполнение будет происходить в том порядке, в котором они были указаны в HTML-документе. |

  Использование `async` и `defer` позволяет улучшить производительность загрузки страницы, так как скрипты могут загружаться
  параллельно с другими ресурсами и не задерживают рендеринг страницы. Однако, необязательно каждый скрипт помечать
  асинхронным или отложенным - в зависимости от конкретных требований страницы и его взаимодействия с другими элементами
  можно выбирать самостоятельно.

## Центрирование по горизонтали:

- С помощью свойства `text-align: center` для элементов с дисплеем `block`.
- Использование свойства `margin: 0 auto;` для блочных элементов с заданной шириной.
- Использование свойства `flex` и его свойства `justify-content: center;` для контейнера с дисплеем `flex`.

## Центрирование по вертикали:

- Использование свойств `display: flex;` и `align-items: center;` для контейнера.
- Позиционирование объекта абсолютно с помощью свойства `top` и `transform: translateY(-50%);`.
- Использование свойства `line-height` с фиксированным значением и задание высоты блока.

## Центрирование обоими способами:

- Использование свойств `flexbox` и `grid` для создания гибкой и адаптивной верстки.
- Использование свойства `position: absolute;` и комбинации свойств `top`, `left`, `right`, `bottom`, `transform` со значениями 50%.
- Использование псевдоэлемента `::before` или `::after` и комбинации свойств `position`, `top`, `left`, `right`, `bottom` со значениями
50%.

## Что такое Critical CSS?
Critical CSS — это метод, который помогает сделать загрузку веб-страниц быстрее. Он работает так:
- Выделение нужных стилей: Определяется, какие стили (CSS) нужны для того, чтобы пользователь сразу увидел часть страницы, которая у него на экране (это называется "above-the-fold").
- Встраивание стилей в HTML: Эти стили помещаются прямо в HTML-код страницы, чтобы браузер мог их сразу применить, не дожидаясь загрузки других файлов со стилями.
- Загрузка остальных стилей позже: Остальные стили загружаются после того, как пользователь увидел первую часть страницы, что также помогает ускорить загрузку.

Преимущества Critical CSS:
- Страница загружается быстрее.
- Пользователи быстрее видят контент.
- Это может помочь улучшить позиции сайта в поисковых системах.

## Что такое Styled-components?
Styled-components — это библиотека для создания стилей в приложениях на React. Вот как она работает:

- Создание компонентов: Вы можете создавать кнопки, заголовки и другие элементы с их стилями прямо в JavaScript. Например, можно сделать кнопку синей с белым текстом.

- Использование JavaScript для стилей: Вы можете использовать переменные и условия, чтобы менять стили в зависимости от того, что происходит в приложении. Например, кнопка может быть синей, если она активна, и серой, если нет.

- Уникальные классы: Styled-components автоматически создают уникальные имена для стилей, чтобы избежать путаницы между разными элементами.

- Поддержка тем: Вы можете легко менять стили для разных тем, например, для светлой и темной.

Преимущества styled-components:
- Стили каждого элемента изолированы, что предотвращает конфликты.
- Легко менять стили в зависимости от состояния приложения.
- Удобно работать, так как стили и логика находятся в одном месте.

## Адаптивная верстка

Адаптивная верстка — это подход, при котором веб-страница имеет несколько заранее заданных макетов для разных размеров экранов. Например, сайт может выглядеть по-разному на компьютере, планшете и смартфоне.

- Как это работает: Разработчик создает несколько версий страницы для разных устройств. Когда вы открываете сайт, он определяет, какое устройство вы используете, и загружает соответствующий макет.
- Плюсы: Сайты выглядят хорошо на всех устройствах, так как для каждого размера экрана разработан отдельный дизайн.
- Минусы: Это может потребовать больше времени и усилий для создания и поддержки нескольких версий.

## Резиновая верстка
Резиновая верстка — это подход, при котором элементы страницы изменяют свои размеры в зависимости от ширины окна браузера.

- Как это работает: Используются относительные единицы измерения (например, проценты), чтобы элементы могли растягиваться и сжиматься вместе с окном браузера. Например, если у вас есть блок шириной 50%, он всегда будет занимать половину ширины экрана, независимо от его размера.
- Плюсы: Сайты хорошо адаптируются к любым размерам экранов, и пользователи могут изменять размер окна браузера, не теряя удобства.
- Минусы: Иногда элементы могут выглядеть слишком маленькими или слишком большими на экранах с очень разными размерами.

## Отзывчивая верстка
Отзывчивая верстка (или "responsive design") — это современный подход, который сочетает в себе элементы адаптивной и резиновой верстки. Он позволяет страницам автоматически подстраиваться под любой размер экрана.

- Как это работает: Используются гибкие сетки, медиа-запросы и относительные единицы измерения. Это значит, что элементы не только меняют размер, но и могут перестраиваться в зависимости от ширины экрана. Например, на большом экране элементы могут располагаться в ряд, а на маленьком — один под другим.
- Плюсы: Сайты выглядят хорошо на всех устройствах и экранах, независимо от их размера. Это наиболее универсальный и современный подход.
- Минусы: Может потребовать больше времени на разработку, так как нужно учитывать множество различных размеров и конфигураций.

# JavaScript
>JavaScript — это однопоточный (задачи выполняются последовательно, одна за другой, и в любой момент времени только одна операция может выполняться в рамках данного потока) язык программирования, который используется для создания интерактивных элементов на веб-страницах. Он позволяет добавлять динамику и взаимодействие, например, реагировать на нажатия кнопок, изменять содержимое страницы без перезагрузки и создавать анимации. JavaScript работает в браузере, что делает его основным инструментом для веб-разработки.
***

## Основные нововведения в es6

- `let`
- деструктуризация (сразу достаю свойства через `{}`)
- стрелочные функции
- Операторы расширения (Spread и Rest)
  Spread: Позволяет развернуть массив или объект.
  Rest: Позволяет собирать оставшиеся аргументы в массив.
- Promis

## Виды тестирования (необязательно)

- Юнит - тестирование 1 компонента
- Интеграционное - тестирование группы компонентов
- Системное - тестирование всего приложения

## Отличия var, let, const

- `var` - глобальная область видимости, можно вызвать до её определения (hoisting)
- `let` - область видимости блочная, то есть где она объявлена, там и доступна. Вызывать можно только после её
  определения, иначе будут ошибки. Можно переопределить
- `const` - нельзя переопределить

## Что такое hoisting?

Hoisting (поднятие) - значит, что объявление переменной или функции перемещается в начало кода

## Как создать объект в js?

- через синтаксис «конструктор объекта» (ключевое слово `new`)

```javascript
let user = new Object()
```

- через синтаксис «литерал объекта»

```javascript
let user = {} // свойство - пара «ключ:значение»
```

## Отличие между while и for

- for принимает в себя 3 параметра - начальное значение, условие, шаг
- while выполняется пока принимаемое значение `boolean` не станет `false`

## Способы для сравнения объектов

- `JSON.stringify` - конвертирует объекты в строку и сравнивает.
  Но если свойства объектов идут не в одном порядке, то сравнение вернет false
- с помощью библиотеки __lodash_, есть метод `_.isEqual(объект1, объект2)`

## Зачем нужен оператор typeof?

Оператор typeof позволяет определить тип параметра. Он возвращает строку содержащую тип (string, number, object)

Особенности:

- Для null оператор возвращает object
- Для функций оператор возвращает function

## Что такое чистая функция?

Это функция работающая только с теми аргументами, которые в нее передали, и не имеющая side эффектов (сторонних
эффектов). То есть делает, что-то одно

## Что такое замыкание (closures) ?

Замыкание - это функция в функции, то есть внутренняя функция имеет доступ к данным родительской функции.

## Разница между стрелочной и обычной функции.

- В стрелочной функции отсутствует специальный объект `arguments`, содержащий в себе объект со всеми аргументами
  функции.
- Значение `this` внутри обыкновенной функции динамически зависит от контекста вызова. Собственный `this` внутри
  стрелочной функции отсутствует (`undefined`). Но когда стр. ф-ия используется в замыкании, то её `this` будет
  указывать на `this` внешней функции.
- Обычная функция (не анонимная) может быть вызвана до своего определения
- Если в стрелочная функция пишется в одну строку, можно не указывать `return`
- Можно использовать синтаксис стрелочных функций внутри класса. При этом в качестве `this` будет выступать объект
  класса.

## Различие function declaration и function expression

- _function declaration_ - должно содержать ключевое слово function, вызвать можно как до так и после его определения
- _function expression_ - вызвать можно только после определения

## Минусы callback функции

- Функция должна быть выполнена после того, как другая функция завершила выполнение
- Легко потеряться во вложенности

## Разница между операторами `=`, `==` и `===`

- `=` оператор присвоения
- `==` является не строгим сравнением (приводит типы данных к 1 виду)
- `===` строгое сравнение данных (без приведения типов)

## Rest & Spread операторы

В чем разница между spread-оператором и rest-оператором?
Операторы spread и rest имеют одинаковый синтаксис (`...`). Разница состоит в том, что с помощью spread мы передаем или
распространяем данные массива на другие данные, а с помощью rest — получаем все параметры функции и помещаем их в
массив (или извлекаем часть параметров).

## Что такое деструктуризация объекта (Object Destructuring)?
**Деструктуризация** — относительно новый способ получения (извлечения) значений объекта или массива. Использование
деструктуризации позволяет сделать код чище и отнимает меньше времени. Синтаксис деструктуризации следующий: заключаем
свойства объекта, которые хотим получить, в фигурные скобки (`{ }`), а если речь идет о массиве — в квадратные
скобки (`[ ]`)

## Оператор "!!"

`!!` (двойное отрицание) приводит значение справа от него к логическому значению.

## Типы данных

8 типов данных (7 примитивов и 1 непримитив)

- string - строка
- number - число
- boolean - логическое значение true/false
- null - специальное значение, указывает на его отсутствие
- underfined - специальное значение, указывает на то, что значение не установлено
- symbol - уникальное значение, часто применяется для обращения к свойствам сложных объектов
- bigint - очень большое число
- object - комплексный объект, составной тип данных, туда же массивы и функции

## В чем разница null и undefined?

`null` указывает на отсутствие значения, а `undefined` на его неопределенность

## Как можно привести одни типы к другим?

Преобразовать можно к `string`, `number`, `boolean`

- явное преобразование

```javascript
const age = 2
String(age) // "2"
```

- неявное с помощью конкатенации значения со строкой
  (к строке приводиться только при сложении)
  В остальных случаях (-, /, *) приравнивается к числу

```javascript
const age = 30 + "2" // "302"
```

## Что такое NaN, как проверить является ли значение NaN?

`NaN` - not a number (не число), способ проверки через функцию

```javascript
isNaN(значение)
```

## Какое значение имеет this?

`This` - ключевое слово, которое указывает на текущий контекст выполнения кода, если использовать `this` внутри какого-либо
объекта, то `this` ссылается именно на этот объект

## Методы `bind`, `call`, `apply` - привязывают контекст к какой-либо функции

- в метод `call()` параметры функции передаются через запятую
- в метод `apply()` в массив
- отличие `bind()` от `call()` и `apply()`, в том что `bind()` не вызывает функцию, он создает новую функцию с новым
  контекстом.
  Параметры передаются через запятую, как и в `call()`.

## Какой из этих методов быстрее и почему?

`push`/`pop` быстрее потому что работают с элементами в конце массива, а `unshift`/`shift` с его началом и для этих
операций требуется переиндексация всего массива

## Что если использовать вместо `pop`/`shift`/`splice` - `_delete_`?

На месте удаленных элементов останется `undefined`

## Мутирующие методы массивов

Мутирующие методы массивов в JavaScript — это методы, которые изменяют сам массив, на котором они вызываются. 

- `push()`: Добавляет один или несколько элементов в конец массива и возвращает новую длину массива.

```jsx
const arr = [1, 2, 3];
arr.push(4); // arr теперь [1, 2, 3, 4]
```

- `pop()`: Удаляет последний элемент из массива и возвращает его. Этот метод изменяет длину массива.

```jsx
const arr = [1, 2, 3];
const lastElement = arr.pop(); // lastElement = 3, arr теперь [1, 2]
```

- `shift()`: Удаляет первый элемент из массива и возвращает его. Это также изменяет длину массива.

```jsx
const arr = [1, 2, 3];
const firstElement = arr.shift(); // firstElement = 1, arr теперь [2, 3]
```

- `unshift()`: Добавляет один или несколько элементов в начало массива и возвращает новую длину массива.

```jsx
const arr = [1, 2, 3];
arr.unshift(0); // arr теперь [0, 1, 2, 3]
```

- `splice()`: Изменяет содержимое массива, удаляя или заменяя существующие элементы и/или добавляя новые элементы на место.

```jsx
const arr = [1, 2, 3, 4];
arr.splice(1, 2, 5, 6); // arr теперь [1, 5, 6, 4]
// Удалены 2 элемента, начиная с индекса 1, и добавлены 5 и 6.
```

- `sort()`: Сортирует элементы массива на месте и возвращает ссылку на отсортированный массив.

```jsx
const arr = [3, 1, 4, 2];
arr.sort(); // arr теперь [1, 2, 3, 4]
```

- `reverse()`: Изменяет порядок элементов массива на противоположный и возвращает ссылку на изменённый массив.

```jsx
const arr = [1, 2, 3];
arr.reverse(); // arr теперь [3, 2, 1]
```

- `fill()`: Заполняет все элементы массива статическим значением, начиная с определенного индекса и заканчивая другим индексом.

```jsx
const arr = [1, 2, 3];
arr.fill(0); // arr теперь [0, 0, 0]
```

## Немутирующие методы

- `map()`: Создает новый массив, заполняя его результатами вызова предоставленной функции для каждого элемента массива.

```jsx
const arr = [1, 2, 3];
const doubled = arr.map(x => x * 2); // doubled: [2, 4, 6]
```

- `filter()`: Создает новый массив, содержащий все элементы, которые прошли проверку, заданную предоставленной функцией.

```jsx
const arr = [1, 2, 3, 4];
const evenNumbers = arr.filter(x => x % 2 === 0); // evenNumbers: [2, 4]
```

- `reduce()`: Применяет функцию к каждому элементу массива (слева направо), чтобы свести его к единому значению.

```jsx
const arr = [1, 2, 3, 4];
const sum = arr.reduce((accumulator, current) => accumulator + current, 0); // sum: 10
```

- `forEach()`: Выполняет указанную функцию один раз для каждого элемента массива. Этот метод не возвращает новый массив.

```jsx
const arr = [1, 2, 3];
arr.forEach(x => console.log(x)); // Вывод: 1, 2, 3
```

- `every()`: Проверяет, удовлетворяют ли все элементы массива условию, заданному в предоставленной функции. Возвращает true, если все элементы соответствуют, и false в противном случае.

```jsx
const arr = [2, 4, 6];
const allEven = arr.every(x => x % 2 === 0); // allEven: true
```

- `some()`: Проверяет, удовлетворяет ли хотя бы один элемент массива условию, заданному в предоставленной функции. Возвращает true, если хотя бы один элемент соответствует, и false в противном случае.

```jsx
const arr = [1, 2, 3];
const hasEven = arr.some(x => x % 2 === 0); // hasEven: true
```

- `find()`: Возвращает первый элемент массива, который удовлетворяет условию, заданному в предоставленной функции. Если ни один элемент не найден, возвращает undefined.

```jsx
const arr = [1, 2, 3, 4];
const found = arr.find(x => x > 2); // found: 3
```

- `findIndex()`: Возвращает индекс первого элемента массива, который удовлетворяет условию, заданному в предоставленной функции. Если ни один элемент не найден, возвращает -1.

```jsx
const arr = [1, 2, 3, 4];
const index = arr.findIndex(x => x > 2); // index: 2
```

- `slice()`: Возвращает новый массив, содержащий копию части исходного массива, начиная с указанного начального индекса и заканчивая конечным индексом (не включая его).

```jsx
const arr = [1, 2, 3, 4];
const newArr = arr.slice(1, 3); // newArr: [2, 3]
```

- `concat()`: Создает новый массив, который является объединением двух или более массивов.

```jsx
const arr1 = [1, 2];
const arr2 = [3, 4];
const newArr = arr1.concat(arr2); // newArr: [1, 2, 3, 4]
```

- `includes()`: Проверяет, содержит ли массив определенный элемент, и возвращает true или false.

```jsx
const arr = [1, 2, 3];
const hasTwo = arr.includes(2); // hasTwo: true
```

- `join()`: Создает и возвращает строку, состоящую из всех элементов массива, объединенных указанной строкой-разделителем.

```jsx
const arr = ['Hello', 'World'];
const str = arr.join(' '); // str: 'Hello World'
```

## Методы строк

- `toUpperCase()`, `toLowerCase()` (смена регистра)
- `indexOf()`, `includes()` (поиск символов в строке)
- `slice()`, `substring()` (обрезка строки)
- `replace()`, `replaceAll()` (замена символов в строке)
- `repeat()` (повторение строки несколько раз)
- `trim()` (удаление лишних пробелов)

## Что такое Object.freeze?

`Object.freeze()` замораживает объект: это значит, что он предотвращает добавление новых свойств к объекту, удаление
старых свойств из объекта и изменение существующих свойств или значения их атрибутов перечисляемости, настраиваемости и
записываемости. В сущности, объект становится эффективно неизменным. Метод возвращает замороженный объект.

## Что такое Object.seal?

`Object.seal()` запечатывает объект, предотвращая добавление новых свойств к объекту и делая все существующие свойства
не настраиваемыми. Значения представленных свойств всё ещё могут изменяться, поскольку они остаются записываемыми

## В чем разница между методами Object.freeze и Object.seal?

Разница заключается в том, что при использовании метода `Object.freeze()` мы не можем менять или редактировать свойства
объекта, а при использовании `Object.seal()` такая возможность имеется, но в обоих случаях нельзя удалять и добавлять новые поля

## ООП - объектно ориентированное программирование (парадигма - это способ мышления, способ восприятия чего-либо)

- **Абстракция** - выделение важного для решения задач
- **Инкапсуляция** - сокрытие сложной реализации под понятным интерфейсом
- **Наследование** - перенятие свойств и методов одного класса другим
- **Полиморфизм** - возможность метода работать с аргументом и его наследниками

## Классы

- Наследование классов, `super()`
- Статические свойства и методы
- Приватные и защищённые методы и свойства

## Event, event listener, handler

Объект Event описывает событие, произошедшее на странице. Одной из причин возникновения событий являются действия
пользователя, такие как клики мышкой MouseEvent или ввод с клавиатуры KeyboardEvent

- **Event listener** - прослушиватель событий
- **Handler** - обработчик событий

## Что такое распространение события (Event Propagation)?

Когда какое-либо событие происходит в элементе DOM, оно на самом деле происходит не только в нем. Событие
«распространяется» от объекта Window до вызвавшего его элемента (event.target). При этом событие последовательно
пронизывает (затрагивает) всех предков целевого элемента. Распространение события имеет три стадии или фазы:

- Фаза погружения (захвата, перехвата) — событие возникает в объекте Window и опускается до цели события через всех ее
  предков.
- Целевая фаза — это когда событие достигает целевого элемента.
- Фаза всплытия — событие поднимается от event.target, последовательно проходит через всех его предков и достигает
  объекта Window.

## Что такое всплытие события?

Когда событие происходит в элементе DOM, оно затрагивает не только этот элемент. Событие «всплывает» (подобно пузырьку
воздуха в воде), переходит от элемента, вызвавшего событие (event.target), к его родителю, затем поднимается еще выше, к
родителю родителя элемента, пока не достигает объекта Window.

## Что такое погружение события?

Когда событие происходит в элементе DOM, оно происходит не только в нем. В фазе погружения событие опускается от объекта
Window до цели события через всех его предков.

## В чем разница между методами `event.preventDefault()` и `event.stopPropagation()`?

- `event.preventDefault()` отключает поведение элемента по умолчанию. Если использовать этот метод в элементе form, то он
  предотвратит отправку формы (submit). Если использовать его в contextmenu, то контекстное меню будет отключено
- `event.stopPropagation()` отключает распространение события (его всплытие или погружение).

## Как узнать об использовании метода `event.preventDefault()`?

Для этого мы можем использовать свойство `event.defaulPrevented`, возвращающее логическое значение, служащее индикатором
применения к элементу метода `event.preventDefault`.

## Зачем нужна асинхронность и какую проблему она решает?

Асинхронность - это способ взаимодействия с данными, когда не знаешь, в какой точно момент появятся данные.

Если код работает синхронно, то пользователь не сможет взаимодействовать со страницей, пока не придет результат.

Асинхронный код позволяет избежать этого. Он убирает блокирующую операцию из основного потока, пока она где-то
продолжает выполняться, а обработчик может идти дальше

## Event loop

`Event loop` - это событийный цикл, бесконечный цикл в котором JS ожидает задачи, выполняет их и ждет новые.
У него есть свой порядок, выполнения:

- сначала выполняются все макрозадачи (callstack выполнение кода от первой строчки до последней)
- вызывает все, что есть в очереди микрозадач (microtask queue - promise (`than`/`catch`/`finally`))
- вызывает все, что есть в очереди вызовов (callback queue - `setTimeOut()`, `setInterval()`)

## Что такое Promise ?

Promise (обещание) - это объект в JavaScript, представляющий результат асинхронной операции. Promise может находиться в
одном из трех состояний:

- pending (ожидание) - начальное состояние, когда Promise ещё не выполнен и не отклонен.
- fulfilled (выполнено) - состояние, когда Promise успешно выполнен, и берёт на себя ответственность вернуть результат.
- rejected (отклонено) - состояние, когда Promise отклонен из-за ошибки, и берёт на себя ответственность вернуть причину
  этой ошибки.

Promise используется для упрощения работы с асинхронными операциями, такими как запросы к серверу или задержка
выполнения кода. Вместо использования старого стиля с функциями обратного вызова (callback), синхронный код теперь может
быть записан асинхронно с цепочкой промисов и вызовами `.then()` и `.catch()`.

Методы promise:

- `.then()`: Обрабатывает успешное выполнение асинхронной операции. Когда промис завершается успешно (в состоянии "
  fulfilled"), функция, переданная в `.then()`, вызывается с результатом промиса. В `.then()` можно цепочкой добавлять
  последовательные асинхронные операции для обработки.
- `.catch()`: Обрабатывает возникшие ошибки во время выполнения промиса. Если промис завершается с ошибкой (состояние "
  rejected"), функция, переданная в `.catch()`, вызывается с информацией об ошибке. Добавляется после `.then()` для
  обработки ошибок.
- `.finally()`: Выполняет заданную функцию вне зависимости от результата промиса — успешного или ошибочного. Обычно
  используется для выполнения определенных действий, которые должны произойти в любом случае, например, очистка ресурсов
  или скрытие индикатора загрузки.

## Методы промисов

| Тип |Что делает|Когда завершится|Возвращает|
|-----|-|-|-|
|`Promise.all()`|Принимает массив промисов и возвращает новый промис.|Завершится, когда все промисы в массиве будут выполнены успешно.|Массив результатов всех промисов. Если хотя бы один промис отклонен, возвращает ошибку.|
|`.allSettled()`|Также принимает массив промисов и возвращает новый промис.|Завершится, когда все промисы завершатся, независимо от того, были ли они выполнены успешно или отклонены.|Массив объектов с результатами (состояние и значение или причина ошибки) для каждого промиса.|
|`.any()`|Принимает массив промисов и возвращает новый промис.|Завершится, когда хотя бы один промис выполнится успешно.|Результат первого успешно выполненного промиса. Если все промисы отклонены, возвращает ошибку.|
|`.race()`|Принимает массив промисов и возвращает новый промис.|Завершится, как только первый промис завершится (успешно или с ошибкой).|Результат первого завершившегося промиса.|
|`.resolve()`|Создает новый промис, который немедленно выполнен с заданным значением.||Промис с состоянием "выполнен".|
|`.reject()`|Создает новый промис, который немедленно отклонен с заданной причиной.||Промис с состоянием "отклонен".|

> Эти методы позволяют удобно управлять множеством промисов, комбинировать их и обрабатывать результаты асинхронных операций в JavaScript.

## Основные понятия async/await.

- `async`:
  - Это ключевое слово, которое используется перед функцией, чтобы объявить её асинхронной.
  - Асинхронная функция всегда возвращает промис. Если в функции используется значение, оно автоматически оборачивается в промис.

- `await`:
  - Это ключевое слово, которое используется внутри асинхронной функции для ожидания завершения промиса.
  - Когда await встречается, выполнение функции приостанавливается до тех пор, пока промис не выполнится или не будет отклонен.

## Зачем нужны async/await?

- Упрощение кода:
  - async/await делает асинхронный код более читаемым и понятным, похожим на синхронный. Это позволяет избежать "адского колбэка" (когда много вложенных функций).
- Обработка ошибок:
  - С помощью try/catch/finally можно легко обрабатывать ошибки, что делает код чище и проще для понимания.
- Улучшение структуры:
  - async/await позволяет писать код, который легче структурировать и поддерживать, особенно когда есть несколько асинхронных операций, которые нужно выполнять последовательно.

## Почему вредно ставить await в return, например `return await request(...);`

- Избыточность: Использование await перед return избыточно. Когда вы возвращаете промис из `async` функции, он автоматически оборачивается в другой промис. То есть, если вы просто напишете `return request(...)`, это будет работать так же, как и `return await request(...)`, но без лишней задержки.
- Потеря контекста ошибок: Если вы используете `return await`, и промис отклоняется, это может затруднить отладку. Ошибка будет выброшена в контексте функции, где вы использовали `await`, а не в месте вызова, что может сделать стек вызовов менее информативным.
- Производительность: Использование `await` в return может немного снизить производительность, так как это добавляет лишнюю задержку в обработку, хотя это и незначительно.

## Разница setTimeOut и setInterval

- `setTimeOut()` - позволяет вызвать функцию один раз через определенный интервал времени
- `setInterval()` - позволяет вызывать функцию регулярно, повторяя вызов через определенный интервал времени

## Объекты Set и Map

`Set` — это как корзина с уникальными предметами, а `Map` — это как словарь с парами "ключ-значение".

1. Set (Множество) — это коллекция уникальных значений. Представьте себе корзину, в которую вы можете добавлять фрукты, но каждый фрукт можно добавить только один раз. Если вы попытаетесь добавить тот же фрукт снова, он будет проигнорирован.

Пример:

```jsx
const mySet = new Set(['яблоко', 'банан', 'апельсин', 'яблоко']);
console.log(mySet); // Вывод: Set {'яблоко', 'банан', 'апельсин'}
```

Ключевые особенности:
  - Только уникальные значения
  - Дубликаты не допускаются
  - Быстрый поиск, добавление и удаление элементов

2. Map (Словарь) — это коллекция пар "ключ-значение". Представьте себе словарь, в котором вы можете хранить слова и их значения.

Пример:

```jsx
const myMap = new Map([
['имя', 'Иван'],
['возраст', 30],
['город', 'Москва']
]);
console.log(myMap.get('имя')); // Вывод: Иван
```

Ключевые особенности:
- Пары "ключ-значение"
- Каждый ключ уникален
- Быстрый поиск, добавление и удаление пар "ключ-значение"

## Объекты WeakSet и WeakMap

1. WeakSet (Слабое множество) — это коллекция уникальных объектов, но в отличие от обычного Set, WeakSet не предотвращает сборку мусора для объектов, находящихся в нем. Это означает, что если на объект больше нет ссылок, он может быть удален из памяти, даже если он находится в WeakSet.

Пример:

```jsx
let obj1 = { имя: 'Иван' };
let obj2 = { имя: 'Петр' };
const myWeakSet = new WeakSet([obj1, obj2]);

console.log(myWeakSet.has(obj1)); // Вывод: true

obj1 = null; // Удаляем ссылку на obj1
// Теперь obj1 может быть удален сборщиком мусора
```

Ключевые особенности:
- Хранит только объекты
- Не предотвращает сборку мусора
- Не имеет методов для итерации (например, no forEach)

2. WeakMap (Слабый словарь) — это коллекция пар "ключ-значение", где ключи являются объектами, а значения могут быть любого типа. Как и в WeakSet, если на ключ больше нет ссылок, он может быть удален из памяти.

Пример:

```jsx
let objKey = {};
const myWeakMap = new WeakMap();

myWeakMap.set(objKey, 'значение');
console.log(myWeakMap.get(objKey)); // Вывод: 'значение'

objKey = null; // Удаляем ссылку на objKey
// Теперь objKey может быть удален сборщиком мусора
```

Ключевые особенности:
- Ключи — только объекты
- Не предотвращает сборку мусора
- Не имеет методов для итерации

# TypeScript
>TypeScript — это надстройка над JavaScript, которая добавляет статическую типизацию. Это значит, что вы можете указывать типы данных (например, число, строка, объект) для переменных и функций. TypeScript помогает находить ошибки на этапе разработки, что делает код более надежным и удобным для работы, особенно в больших проектах. В конечном итоге, TypeScript компилируется в обычный JavaScript, чтобы работать в браузерах.
***

## Назовите плюсы и минусы TS?

Плюсы:

- строгая типизация
- интерфейсы
- ооп
- компилятор реализует подход fail fast (получаешь обр. связь в момент написания кода а не в момент тестирования)
- очень хорошая поддержка TS в редакторах кода (советы, ошибки, и кододополнение намного лучше чем в JS)

Минусы:

- нужно больше учить (выше порог входа)
- Существующий код сложно перенести на TS
- Код из библиотек бывает сложно читать из-за обилия дженериков и прочего

_**Прим:**_ Некоторые библиотеки и фреймворки (например Angular) работают только с TS

## Почему нерекомендуется использовать any?

Тогда TS превращается в JS, тк «убивается» типизация

## Для чего нужны дженерики?

Дженерики в TypeScript являются мощным инструментом для создания гибкого и безопасного кода. Они помогают разработчикам писать более универсальные и устойчивые приложения, улучшая читаемость и поддерживаемость кода.

- Дженерики позволяют избежать ошибок, связанных с неправильным использованием типов, за счет проверки типов на этапе компиляции. Это помогает выявлять ошибки до запуска программы.
- С помощью дженериков можно создавать обобщенные функции и классы, которые могут работать с различными типами данных. Это уменьшает дублирование кода и делает его более универсальным.
- Код с дженериками становится более понятным, так как явным образом указываются ожидаемые типы данных. Это облегчает понимание кода и его поддержку.
- Дженерики позволяют создавать более гибкие API, которые могут адаптироваться к различным типам данных, что делает код более модульным и переиспользуемым.
- Дженерики часто используются для создания обобщенных коллекций (например, массивов, списков, карт), что позволяет хранить элементы разных типов, обеспечивая при этом безопасность типов.

## разница между type и interface?

- `type` не может расширяться в отличие от `interface`
- `type` может быть объявлен только 1 раз. Если интерфейс объявляется 2 раза, то его свойства «сливаются»
- Тип не может быть реализован, только объявлен. Интерфейс нужно реализовывать

## Зачем нужен тип unknow?

`unknown` является безопасной (с точки зрения типов) версией типа `any`.
Когда свойство объявлено как `any`, у него становится поведение как у обычного JS поля. Если поле объявлено
как `unknown`, у него нельзя вызвать никакого метода или свойства без явной проверки `unknown` на конкретный тип (
через `typeof`)



# React

>React — это библиотека JavaScript для создания пользовательских интерфейсов. Она помогает разработчикам строить веб-приложения, разбивая интерфейс на небольшие, переиспользуемые компоненты. React делает работу с динамическим контентом более удобной и эффективной, позволяя обновлять только те части страницы, которые изменились, а не перезагружать всю страницу.
***

## Что такое JSX?

JSX является расширением синтаксиса JavaScript и поставляется с полной функциональностью JavaScript. JSX производит
«элементы» React. Вы можете встроить любое выражение JavaScript в JSX, заключив его в фигурные скобки. После компиляции
выражения JSX становятся обычными объектами JavaScript. Это означает, что вы можете использовать JSX внутри операторов
if и циклов for, назначать его переменным, принимать в качестве аргументов и возвращать из функций.

## Что такое контролируемые компоненты?

В контролируемом компоненте данные формы обрабатываются состоянием внутри компонента. Состояние внутри компонента служит
«единственным источником правды» для элементов ввода, которые отображаются компонентом. Нам не нужен элемент формы на
странице, чтобы компонент был контролируемым компонентом.

## Что такое некотролируемые компоненты?

Неконтролируемые компоненты действуют больше как традиционные элементы формы HTML. Данные для каждого элемента ввода
хранятся в DOM, а не в компоненте. Вместо того чтобы писать обработчик событий для всех ваших обновлений состояния, вы
используете ref для получения значений из DOM.

## Фазы жизненного цикла компонентов React

| Тип | Описание                                                                                                                                                                                                       |
|-----|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|**Монтирование**| компонент React готов для монтирования в DOM браузера. Этот этап охватывает методы жизненного цикла `componentDidMount`                                                                                        |
|**Обновление**| на этом этапе компонент обновляется двумя способами, отправляя свойства и обновляя состояние. Этот                       этап охватывает методы жизненного цикла `shouldComponentUpdate`, `componentDidUpdate` |
|**Размонтирование**| на этом последнем этапе компонент не нужен и отключается из DOM браузера, этот этап включает метод `componentWillUnmount`|

Дополнительно:

- componentWillMount- перед рендерингом, в основном для настройки компонента
- render- процесс рендеринга
- componentDidMount- уведомляет, про то, что компонент соединен с DOM
  деревом
- componentWillReceiveProps- уведомляет, про то, что приходят новые
  входящие свойства в компонент
- shouldComponentUpdate- возвращает true или false и служит для
  оптимизации. Решает, нужно ли делать ре-рендеринг
- componentWillUpdate- уведомляет, что компонент будет обновлен
- componentDidUpdate- уведомляет, что компонент был обновлен
- componentWillUnmount- используется для удаления слушателей и очистки
  компонента. Вызывается перед удалением компонента

## Что такое Props?

Props это короткое название Properties в React. Они только для чтения. Они всегда передаются вниз от родителя к ребёнку.
Дочерний компонент никогда не может передать prop обратно родителю. Это помогает поддерживать однонаправленный поток
данных и обычно используется для рендера динамически генерируемых данных.

## Что такое состояние React?

State - это объект, которые определяют рендеринг и поведение компонентов. Он мутабельный и создает динамические и
интерактивные компоненты. После изменения state происходит ре-рендер компонента

## Для чего нужны keys в React?

Ключи используются для идентификации уникальных виртуальных элементов DOM с соответствующими данными, управляющими
пользовательским интерфейсом. Они помогают React оптимизировать рендеринг, перерабатывая все существующие элементы в
DOM. Эти ключи должны быть уникальными числами или строками, используя которые React просто переупорядочить элементы, а
не перерисовывает их. Это повышает производительность приложения.

## Для чего в React используется Virtual Dom?

Самые затратные операции в JS - это работа с DOM-дерево, это такие функции как `document.querySelector()`
или `getElementById()`.

То есть каждый раз, когда мы берем JS и делаем доступ до DOM-дерево, то требуется некоторое количество времени для того,
чтобы найти и получить в JS.

Когда приложение интерактивное и много взаимодействий, оно может тормозить.

Virtual Dom - легковесный JS объект, который представляет копию реального DOM-дерева

Нужен он для оптимизации взаимодействия с DOM

## Хуки

Хуки - это функции, с помощью которых можно подцепиться к состоянию и методам жизненного цикла React из функциональных
компонентов

Преимущество хуков : Хуки позволяют повторно использовать логику состояния, писать код проще, эффективнее использовать функционал, упрощает
разработку за счет декларативности

| Тип | Описание                                                                                | Пример |
|-----|-----------------------------------------------------------------------------------------|--------|
|`useState()`| управление состояние функционального компонента React                                   |`const [state, setState] = useState() // state - переменная, которая хранит само состояние // setState - функция, которая меняет состояние // (initialState) - начальное значение состояния`|
|`useEffect()`| используя этот хук мы говорим React сделать что-то после рендера. React запомнит это и вызовет функцию после того, как внесет изменения в DOM| `useEffect(() => {}, []) // [] - зависимости, при изменении которых срабатывает рендер` |
|`useContext()`| получение контекста в дочерних элементах                                                ||
|`useHistory()`|                                                                                         ||
|`useLocation()`|                                                                                         ||

## Из сторонних библиотек

- `useTable()` из React.Table
- `useForm()`

## Для чего нужен ref?

`ref` - это атрибут в React, который помогает хранить ссылку на определенный элемент или компонент, который будет
возвращен функцией конфигурации рендеринга компонентов.

Нужен:

- для интеграции со сторонами библиотеки
- когда нужно работать с фокусом, выделить текст или работа с медиа
- Для запуска императивной анимации (Императивная анимация работает в браузере основным потоком.)

## Что такое Context?

Контекст позволяет передавать данные через дерево компонентов без необходимости передавать пропсы на промежуточных
уровнях.

## MVC

Архитектурный паттерн в котором приложение представляется в виде 3 слоёв:

- **_Model_** - слой данных. В него входят базы данных.
- **_View_** - слой представления. В него входит весь фронт-энд.
- **_Controller_** - слой управления данными. Он же бэк-энд

## Что такое компоненты высшего порядка (High Order Component)?

HOC это кастомный компонент, который оборачивает другой компонент. Может принять любой динамически предоставленный
дочерний компонент, но они не будут изменять или копировать любое поведение из своих компонентов. Можно сказать что HOC
это чистый компонент.

## Действия с HOC

- Переиспользование кода, логики
- Абстракция и манипуляция state
- Манипуляция с props

## Flux

Flux - это архитектурный паттерн, который обеспечивает однонаправленный поток данных. Он контролирует производные данные
и обеспечивает связь между несколькими компонентами с использованием центрального хранилища, которые имеет полномочия
для всех данных. Любое обновление данных должно происходить только здесь. Flux обеспечивает стабильность приложения и
уменьшает ошибки во время выполнения.

## Разница между Презентационным и Контейнер компонентом?

- Презентационный - “как вещи выглядят”. Нужен для создания интерфейса. Работает на входящих параметрах
- Контейнер - “как вещи работают”. Обладают состоянием, подключены к Flux или Redux

# Redux
>Redux — это библиотека для управления состоянием приложения, которая часто используется вместе с React. Она помогает организовать данные в приложении, чтобы все компоненты могли легко получать доступ к нужной информации и обновлять её. Redux хранит состояние приложения в одном месте, что упрощает отслеживание изменений и делает приложение более предсказуемым.
***

## Принципы Redux?

- Единый источник правды: Состояние всего приложения хранится в дереве объектов/состояний в одном хранилище. Единое
  дерево состояний облегчает отслеживание изменений и отладку или проверку приложения.
- State только для чтения: Единственный способ изменить state вызвать Action. Action - это просто объект JS описывающий
  изменение.
- Изменения сделаны чистыми функциями: Чтобы указать, как дерево состояний трансформируется действиями, вам нужны чистые
  функции.

## Принципы Redux?

- Единый источник правды: Состояние всего приложения хранится в дереве объектов/состояний в одном хранилище. Единое
  дерево состояний облегчает отслеживание изменений и отладку или проверку приложения.
- State только для чтения: Единственный способ изменить state вызвать Action. Action - это просто объект JS описывающий
  изменение.
- Изменения сделаны чистыми функциями: Чтобы указать, как дерево состояний трансформируется действиями, вам нужны чистые
  функции.

## Компоненты Redux

- `Action` - Объект, который описывает что происходит
- `Reducer` - Место, где определяется как state изменится
- `Store` - Состояние/Объект дерева всего приложения которое хранится в Store
- `View` - Отображает данные, предоставленные Store

## Как `Actions` определяются в Redux?

`Action` в React должны иметь свойство `type` которое показывает тип Action. Они должны быть определены как строковая
константа, можно добавить еще свойства. В Redux actions создаются при помощи функции которая возвращает типа и данные.

## Объясните роль Reducer?

Reducers это чистые функции которые описывают как состояние приложения изменяется в ответ на `Action`. Reducer работает
принимая прежнее состояние и действие, а затем возвращает новое состояние. Он определяет, какое обновление необходимо
выполнить, основываясь на типе действия, а затем возвращает новые значение. Возвращает предыдущее состояние если не
нужно выполнять никаких действий

## Каково назначение Store в Redux?

`Store` - это JavaScript объект, который содержит состояние приложения и предоставляет несколько вспомогательных методов
для доступа к состоянию, рассылает действия и регистрирует слушателей. Все дерево состояний/объектов приложения
сохраняется в одном хранилище.

В результате Redux очень просто и предсказуем. Мы можем передать промежуточное программное обеспечение в хранилище для
обработки данных, а также для ведения журнала различных действий, которые изменяют состояние хранилищ. Все действия
возвращают новое состояние через reducers.



# Git
>Git — это система контроля версий, которая позволяет разработчикам отслеживать изменения в коде и работать над проектами совместно. С Git можно легко сохранять разные версии кода, возвращаться к предыдущим версиям, а также объединять изменения, сделанные разными разработчиками. Это особенно полезно в командной работе, так как помогает избежать конфликтов и потери данных.
***

## Назовите основные команды `git`?

| Тип |Описание|
|-----|-|
|git init| инициализация нового репозитория;|
|git clone| клонирование существующего репозитория на локальный компьютер;|
|git add| добавление файлов в индекс (staging area);|
|git commit|  создание коммита с изменениями из staging area;|
|git status|  просмотр состояния репозитория и файлов;|
|git branch|  работа с ветками, создание, переключение и удаление;|
|git checkout|  переключение между ветками или возврат к предыдущему коммиту;|
|git merge| объединение изменений из одной ветки в другую;|
|git pull| получение изменений с удалённого репозитория и их слияние с текущей веткой;|
|git push|  отправка изменений с локальной ветки на удалённый репозиторий;|
|git revert|  отмена одного или нескольких последних коммитов;|
|git log| просмотр истории коммитов.|

## Разница между `merge` и `rebase`?

`Merge` — это процесс объединения изменений из одной ветви с другой веткой. Это позволяет сохранить историю коммитов и
создать новый коммит, который объединяет изменения из обеих веток.

`Rebase` — это способ переписать историю ветки так, чтобы она выглядела как непрерывная последовательность коммитов.
Rebase переносит все изменения из одной ветки в другую ветку, создавая новые коммиты. При этом история коммитов
переписывается, что может привести к потере истории или конфликтам при слиянии с другими ветками.

В целом, merge сохраняет историю коммитов, а rebase её переписывает. Merge обычно используется для объединения работы
нескольких разработчиков, а rebase — для очистки истории коммитов перед отправкой кода на сервер.

## Почему рекомендуют использовать концепцию `git flow`?

`Git flow` — это набор рекомендаций и практик для работы с Git, который помогает организовать процесс разработки
программного обеспечения.

`Git flow` предлагает использовать несколько веток для разных этапов разработки.
Использование `git flow` позволяет разработчикам работать над разными задачами одновременно, не мешая друг другу, а также
упрощает процесс выпуска новых версий продукта.

## Как можно отменить commit?

Чтобы отменить commit в Git, можно использовать команду `git revert`. Она создаёт новый коммит, который отменяет изменения
предыдущего коммита.

Синтаксис команды:

```git revert <commit-hash>```

где `<commit-hash>` — это хеш коммита, который вы хотите отменить.

Обратите внимание, что после выполнения этой команды история коммитов будет изменена, и вы не сможете вернуться к
предыдущему состоянию проекта.

## `merge` + решение конфликтов

`Git merge` — это команда, которая объединяет изменения из одной ветви с другой ветвью. Она позволяет сохранить историю коммитов и создать новый коммит, который объединяет изменения из обеих веток.

Однако иногда при слиянии ветвей могут возникать конфликты. Это происходит, когда изменения в одной ветке затрагивают те же строки кода, что и изменения в другой ветке. В этом случае Git не может автоматически объединить изменения и требует вмешательства разработчика.

## `fetch` и разница с `pull`

- `Git fetch` загружает изменения из удаленного репозитория (например, коммиты, ветки) и обновляет локальные ссылки на эти изменения, но не сливает их с вашей текущей веткой. Это просто обновление информации о том, что есть в удаленном репозитории.

- `Git pull` является комбинацией двух команд: git fetch и git merge. Она сначала загружает изменения из удаленного репозитория (как fetch), а затем автоматически сливает эти изменения с вашей текущей веткой.

## `stash`

`Stash` — это команда, которая временно сохраняет изменения в вашем рабочем каталоге, чтобы вы могли переключиться на другую ветку или выполнить другую задачу. После того как вы закончите работу над другой веткой или задачей, вы можете применить сохранённые изменения обратно к текущей ветке.

## `rebase`

`Rebase` — это процесс перемещения серии коммитов из одной ветки в другую. Это позволяет вам переписать историю вашей ветки так, чтобы она выглядела более линейной и последовательной. Rebase может быть полезен, когда вы хотите объединить несколько веток или удалить ненужные коммиты.

## `squash`

Squash — это способ объединения нескольких коммитов в один. Это полезно, когда у вас есть серия небольших коммитов, которые можно объединить в один более значимый коммит. Squash также может помочь вам упростить историю вашей ветки.

## `reset`

`Reset` — это команда, которая позволяет вам вернуться к предыдущему состоянию вашего репозитория. Вы можете использовать reset для отмены изменений, сделанных в вашей рабочей копии, или для возврата к определённому коммиту.

## `revert commit`

`Revert commit` — это действие, которое отменяет изменения, внесённые определённым коммитом. Revert создаёт новый коммит, который отменяет все изменения предыдущего коммита.

## `cherry-pick`

`Cherry-pick` — это возможность взять отдельный коммит из одной ветви и применить его к другой ветви. Это может быть полезно, если вы хотите добавить определённый набор изменений в свою текущую ветку.

## `patch`

`Patch` — это файл, содержащий изменения кода. В Git патчи используются для обмена изменениями между разработчиками или для создания новых версий программного обеспечения.

## `Git submodules`

`Git submodules` — это функция Git, которая позволяет включать в проект другие проекты как подмодули. Подмодули имеют свою собственную историю и могут быть обновлены независимо от основного проекта.

## Gitflow Workflow (релизный цикл, semantic versioning, feature freeze, hotfix)

Эти концепции помогают организовать процесс разработки, улучшить качество кода и упростить управление версиями.

- Gitflow Workflow — это модель работы с Git, которая помогает организовать процесс разработки и управления версиями. Она включает в себя несколько ключевых веток:
  - main (или master): Основная ветка, которая содержит стабильные версии продукта.
  - develop: Ветка для разработки, где происходит интеграция новых функций и улучшений.

- Релизный цикл включает в себя следующие этапы:
  - Разработка: Новые функции добавляются в ветку develop.
  - Тестирование: Когда новые функции готовы, создается релизная ветка (например, release/x.y.z) для тестирования и исправления ошибок.
  - Релиз: После успешного тестирования изменения сливаются в main и develop, и создается новый релиз.

- Semantic Versioning (Семантическое версионирование) — это система нумерации версий, которая выглядит так: MAJOR.MINOR.PATCH.
  - MAJOR: Изменяется, когда вносятся несовместимые изменения.
  - MINOR: Изменяется, когда добавляются новые функции, но сохраняется обратная совместимость.
  - PATCH: Изменяется, когда исправляются ошибки, не влияющие на функциональность.

- Feature Freeze — это этап, когда разработка новых функций приостанавливается. Это позволяет сосредоточиться на тестировании и исправлении ошибок перед релизом. В этот период вносятся только критические исправления.

- Hotfix — это срочное исправление, которое вносится в основную ветку (например, main) для устранения критических ошибок в уже выпущенной версии. После внесения hotfix изменения также сливаются обратно в develop, чтобы обеспечить их наличие в будущих релизах.

